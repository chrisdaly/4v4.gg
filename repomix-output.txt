This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-26T13:38:06.016Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Info

For more information about Repomix, visit: https://github.com/yamadashy/repomix

# Repository Structure
```
public/
  index.html
  robots.txt
src/
  charts/
    LineGraphPlot.js
    RangePlot.js
  App.css
  App.js
  App.test.js
  fakeData.js
  FinishedGame.js
  FinishedGamePage.js
  Game.js
  index.css
  index.js
  Ladder.js
  LineGraphPlotSection.js
  Match.js
  MatchHeader.js
  Mmr.js
  MmrComparison.js
  MmrTrend.js
  MyStreamPage.js
  Navbar.js
  OngoingGame.js
  OnGoingGames.js
  params.js
  Player.js
  PlayerProfile.js
  PlayerProfileBackup.js
  PlayerStream.js
  Queue.js
  RankRow.js
  RecentlyFinished.js
  reportWebVitals.js
  Router.js
  SeamlessBackground.js
  setupTests.js
  Team.js
  TeamHeader.js
  Time.js
  utils.js
.gitignore
README.md
```

# Repository Files

## File: public/index.html
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <!-- <link rel="icon" href="%PUBLIC_URL%/logo.svg" /> -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="4v4.GG"
    />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>4v4.GG</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
```

## File: public/robots.txt
```
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:
```

## File: src/charts/LineGraphPlot.js
```javascript
import * as d3 from "d3";

// https://d3-graph-gallery.com/graph/line_basic.html

function LineGraphPlot(id, data) {
  const { teamOneMmrs, teamOneAverageMmr, teamTwoMmrs, teamTwoAverageMmr, league } = data;
  const teamSize = teamOneMmrs.length;

  const padding = 0;
  const teamHeaderHeight = document.getElementsByClassName("ui vertically divided grid team-header team-1")[0].offsetHeight;
  const cardHeight = document.getElementsByClassName("ui vertically divided grid playerCard")[0].offsetHeight;

  const margin = { top: teamHeaderHeight, right: 0, bottom: padding, left: 0 };
  const width = 49.75;
  const height = 5 + cardHeight * 4;
  const svgHeight = 5 + document.getElementsByClassName("teamDiv")[0].offsetHeight; //height + teamHeaderHeight;
  // console.log("svgHeight", svgHeight);
  const verticalOffset = 15;

  let minMmr = 900; //d3.min(combinedMmrs);
  let maxMmr = 2550; //d3.max(combinedMmrs);

  const y = d3.scaleLinear().domain([minMmr, maxMmr]).range([height, 0]).nice(0);

  var yAxis = d3.axisLeft().scale(y).tickSize(0).ticks(0, ",f");
  let radius = 4;

  const svg = d3
    .select(`#${id}`)
    .append("svg")
    .attr("width", width)
    .attr("height", svgHeight)
    .append("g")
    .attr("transform", "translate(" + width / 2 + "," + margin.top + ")")
    .attr("height", height - margin.top);

  const middleLine = svg.append("g").attr("class", "y axis middle").call(yAxis);

  // Label;
  middleLine
    .append("text")
    .attr("class", "axistitle")
    .text("MMR")
    .attr("x", width / 2 - 25)
    .attr("y", y.range()[1] - teamHeaderHeight / 2);

  // middleLine
  //   .append("text")
  //   .attr("class", "mmrBackground")
  //   .text("1.5k")
  //   .attr("x", width / 2 - 25)
  //   .attr("y", y.range()[0] / 2);

  // badge
  // middleLine
  //   .append("svg:image")
  //   .attr("x", width / 2 - 45)
  //   .attr("y", y.range()[1] - 46)
  //   .attr("width", 40)
  //   // .attr("height", 24)
  //   .attr("xlink:href", leagueIcon);

  // leftLine;
  svg
    .append("line")
    .attr("class", "y axis teamOne")
    .attr("x1", -verticalOffset)
    .attr("y1", (d) => y(d3.max(teamOneMmrs)))
    .attr("x2", -verticalOffset)
    .attr("y2", (d) => y(d3.min(teamOneMmrs)));

  // rightLine
  svg
    .append("line")
    .attr("class", "y axis teamTwo")
    .attr("x1", verticalOffset)
    .attr("y1", (d) => y(d3.max(teamTwoMmrs)))
    .attr("x2", verticalOffset)
    .attr("y2", (d) => y(d3.min(teamTwoMmrs)));

  // avgLine
  svg
    .append("line")
    .attr("class", "y axis avgLine")
    .attr("x1", -verticalOffset)
    .attr("y1", (d) => y(teamOneAverageMmr))
    .attr("x2", verticalOffset)
    .attr("y2", (d) => y(teamTwoAverageMmr));

  // leftDots
  svg
    .selectAll(".dot teamTwo")
    .data(teamTwoMmrs)
    .enter()
    .append("circle")
    .attr("class", "dot teamTwo")
    .attr("r", radius)
    .attr("cx", verticalOffset)
    .attr("cy", (d) => y(d));

  // rightDots
  svg
    .selectAll(".dot teamOne")
    .data(teamOneMmrs)
    .enter()
    .append("circle")
    .attr("class", "dot teamOne")
    .attr("r", radius)
    .attr("cx", -verticalOffset)
    .attr("cy", (d) => y(d));

  // var imgs = svg.selectAll("image").data([0]);
  // imgs.enter().append("svg:image");

  // svg
  //   .selectAll(".mmr axis")
  //   .data(teamTwoMmrs)
  //   .enter()
  //   .append("circle")
  //   .attr("class", "dot teamTwo")
  //   .attr("r", 4)
  //   .attr("cx", function (d) {
  //     return verticalOffset;
  //   })
  //   .attr("cy", function (d) {
  //     return y(d);
  //   });
}

export default LineGraphPlot;
```

## File: src/charts/RangePlot.js
```javascript
import * as d3 from "d3";

function RangePlot(id, data) {
  console.log("data);
  const { teamOneMmrs, teamTwoMmrs } = data;
  const teamOneAverageMmr = teamOneMMrs.reduce((total, num) => total + num, 0) / numbers.length;
  const teamTwoAverageMmr = teamTwoMmrs.reduce((total, num) => total + num, 0) / numbers.length;
  const teamSize = teamOneMmrs.length;
  const league = null;

  // if (document.getElementsByClassName("ui vertically divided grid playerCard")[0] === undefined){
  //   return
  // }

  const padding = 10;
  const teamHeaderHeight = document.getElementsByClassName("team-header")[0].offsetHeight;
  const cardHeight = document.getElementsByClassName("ui vertically divided grid playerCard")[0].offsetHeight;

  const margin = { top: 0, right: 0, bottom: padding, left: 0 };
  const width = 80;
  const height = document.getElementsByClassName("teamDiv")[0].offsetHeight; //8 + cardHeight * 4;
  const svgHeight = 5 + document.getElementsByClassName("teamDiv")[0].offsetHeight; //height + teamHeaderHeight;
  // console.log("svgHeight", svgHeight);
  const verticalOffset = 20;

  let minMmr = 600; //d3.min(combinedMmrs);
  let maxMmr = 2550; //d3.max(combinedMmrs);

  const y = d3.scaleLinear().domain([minMmr, maxMmr]).range([height, 0]).nice(0);

  var yAxis = d3
    .axisLeft()
    .scale(y)
    .tickSize(3)
    .ticks(0, ",f")
    .tickFormat((x) => `${x / 1000}K`);

  let radius = 2.5;

  const svg = d3
    .select(`#${id}`)
    .append("svg")
    .attr("width", width)
    .attr("height", svgHeight + 15)
    .append("g")
    .attr("transform", "translate(" + width / 2 + "," + margin.top + ")")
    .attr("class", "asdasdad");
  // .attr("height", height + 50 - margin.top);

  const middleLine = svg.append("g").attr("class", "y axis middle").call(yAxis);

  // Label;
  middleLine
    .append("text")
    .attr("class", "axistitle")
    .text("MMR")
    .attr("x", 0)
    .attr("y", y.range()[0] + 20);

  // middleLine
  //   .append("text")
  //   .attr("class", "axistitle")
  //   .text("1k")
  //   .attr("x", width / 2 - 25)
  //   .attr("y", y(1000));

  //   middleLine
  //   .append("text")
  //   .attr("class", "axistitle")
  //   .text("2k")
  //   .attr("x", width / 2 - 15)
  //   .attr("y", y(2000));

  // badge
  // middleLine
  //   .append("svg:image")
  //   .attr("x", width / 2 - 45)
  //   .attr("y", y.range()[1] - 46)
  //   .attr("width", 40)
  //   // .attr("height", 24)
  //   .attr("xlink:href", leagueIcon);

  // leftLine;
  svg
    .append("line")
    .attr("class", "y axis teamOne")
    .attr("x1", -verticalOffset)
    .attr("y1", (d) => y(d3.max(teamOneMmrs)))
    .attr("x2", -verticalOffset)
    .attr("y2", (d) => y(d3.min(teamOneMmrs)));

  // rightLine
  svg
    .append("line")
    .attr("class", "y axis teamTwo")
    .attr("x1", verticalOffset)
    .attr("y1", (d) => y(d3.max(teamTwoMmrs)))
    .attr("x2", verticalOffset)
    .attr("y2", (d) => y(d3.min(teamTwoMmrs)));

  // avgLine
  // svg
  //   .append("line")
  //   .attr("class", "y axis avgLine")
  //   .attr("x1", -verticalOffset)
  //   .attr("y1", (d) => y(teamOneAverageMmr))
  //   .attr("x2", verticalOffset)
  //   .attr("y2", (d) => y(teamTwoAverageMmr));

  // leftDots
  svg
    .selectAll(".dot teamTwo")
    .data(teamTwoMmrs)
    .enter()
    .append("circle")
    .attr("class", "dot teamTwo")
    .attr("r", radius)
    .attr("cx", verticalOffset)
    .attr("cy", (d) => y(d));

  // rightDots
  svg
    .selectAll(".dot teamOne")
    .data(teamOneMmrs)
    .enter()
    .append("circle")
    .attr("class", "dot teamOne")
    .attr("r", radius)
    .attr("cx", -verticalOffset)
    .attr("cy", (d) => y(d));

  // var imgs = svg.selectAll("image").data([0]);
  // imgs.enter().append("svg:image");

  // svg
  //   .selectAll(".mmr axis")
  //   .data(teamTwoMmrs)
  //   .enter()
  //   .append("circle")
  //   .attr("class", "dot teamTwo")
  //   .attr("r", 4)
  //   .attr("cx", function (d) {
  //     return verticalOffset;
  //   })
  //   .attr("cy", function (d) {
  //     return y(d);
  //   });
}

export default RangePlot;
```

## File: src/App.css
```css
:root {
  --gold: #fcdb33;
  --green: #34c774;
  --red: #c23434;
  --grey: #d3d3d3;
}

/* @font-face {
  font-family: "Friz_Quadrata_Bold";
  src: url("./fonts/Friz Quadrata Bold.otf") format("opentype");
  font-weight: 1000px;
} */

@font-face {
  font-family: "Friz_Quadrata_Bold";
  src: url(./fonts/friz-quadrata-std-bold-587034a220f9f-webfont.woff) format("woff");
}

@font-face {
  font-family: "Friz_Quadrata_Regular";
  src: url(./fonts/friz-quadrata-std-medium-5870338ec7ef8-webfont.woff) format("woff");
}

/* @font-face {
  font-family: "OPTI-bold";
  src: url(./fonts/OPTIOptionSemiBold.otf) format("opentype");
  font-weight: 1000px;
}

@font-face {
  font-family: "OPTI-bold";
  src: url(./fonts/OPTIOptionSemiBold.otf) format("opentype");
  font-weight: 1000px;
} */

@font-face {
  font-family: "Inconsolata";
  src: local("Inconsolata"), url(./fonts/Inconsolata-Medium.ttf) format("truetype");
}

.App {
  text-align: center;
}

html {
  width: 100vw;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: #fafafa;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

/* .ui.vertically.divided.grid {
  width: 200px;
} */

.three.column.row,
.one.column.row {
  /* padding-top: 0rem;
  padding-bottom: 0rem; */
}

.column {
  margin-top: 0.1rem !important;
  margin-bottom: 0.1rem !important;
}

.ui.vertically.divided.grid {
  /* margin-bottom: 2rem; */
}

.column {
  text-align: center;
}

.ui.three.column.grid,
.ui.one.column.grid {
  margin-bottom: 3rem !important;
}

* {
  /* font-family: "Roboto" !important; */
  color: #fafafa;
}

h1,
h2,
h3 {
  font-family: "Friz_Quadrata_Bold" !important;
}

.key,
.value {
  font-family: "Friz_Quadrata_Bold" !important;
}

body,
.ui.segment,
.ui.vertically.divided.grid {
  /* background-color: #323437; */
  background-color: black !important;

  font-size: 15px;
}

.ui.vertically.divided.grid.team-header.team-2 {
  background-color: #a93232;
  /* outline: 0.5px solid #a93232; */
}

.ui.vertically.divided.grid.team-header.team-1 {
  background-color: #266793;
  /* outline: 0.5px solid #266793; */
}

.playerCard,
.team-header {
  outline: 0.01rem solid var(--grey);
  margin-left: 1px !important;
  margin-right: 1px !important;
  margin-bottom: 1px !important;
  padding-top: 1px !important;
  padding-bottom: 0rem !important;
  border-right: 0;
  /* 
  outline: 1px solid;
  margin-top: 1px;
  margin-left: 1px; */
}

/* .ui.vertically.divided.grid {
 */
/* } */

a {
  color: #fafafa;
}

line.y.axis,
g.y.axis.middle {
  stroke: var(--grey);
  stroke-width: 0.8;
}

/* line.y.axis.teamTwo {
  stroke: #266793;
  stroke-width: 4;
} */

/* circle.dot.teamTwo { */
/* fill: #a93232; */
/* stroke: #323437; */
/* stroke-opacity: 1; */
/* } */

circle.dot.teamOne {
  /* fill: #266793; */
  /* stroke: #323437; */
  /* stroke-opacity: 1; */
}

.ui.vertically.divided.grid.team-header {
  margin-top: 0rem;
}

.ui.container {
  width: 400px !important;
}

.ui.grid > .row > .column {
  padding-left: 0px;
  padding-right: 0px;
}

html {
  /* line-height: 0.5; */
}

.ui.grid > .row {
  padding-top: 0.2rem;
  padding-bottom: 0.2rem;
}

path.domain {
  stroke: white;
  stroke-width: 1px;
}

/* .ui.vertically.divided.grid.playerCard {

} */

.teamDiv {
  padding: 0.1rem;
}

.ui.vertically.divided.grid.playerCard {
  margin-top: 0rem;
}

.ui[class*="vertically divided"].grid > .row:before {
  box-shadow: 0 -0.4px 0 0 #fafafa;
}

h1.ui.header {
  color: #fafafa;
}

text.axistitle {
  fill: #fafafa;
  font-size: 10px;
  text-anchor: middle;
  /* opacity: 1; */
  /* font-weight: bold; */
}

text.mmrBackground {
  fill: #fafafa;
  font-size: 18px;
  text-anchor: middle;
}

svg#svg_logo {
  width: 50px;
  fill: #a93232;
}

.navbar {
  margin-left: -10rem;
  margin-right: -10rem;
  position: sticky;
  top: 0;
  background-color: black;
  z-index: 10000;
}

/* .navbarPlayerCard {
  margin-left: -1 rem;
  margin-right: -1 rem;
  position: sticky;
  top: 175 px !important;
  background-color: #323437;
  z-index: 10000;
} */

.matches {
  /* margin-top: 250px; */
}

.three.column.row {
  display: inline-table;
}

.crown {
  height: 12px;
  /* color: #ffd428; */
  background-color: none important!;
}

.race {
  /* width: 15px;
  height: 15px; */
}

.map,
.league {
  width: 50px;
  height: 50px;
  vertical-align: middle;
}

.mapLabel {
  text-transform: uppercase;
  font-weight: bold;
  margin-top: 5px;
  margin-bottom: 0px;
}

.timeLabel {
  /* text-transform: uppercase; */
  font-weight: 100;
  font-style: italic;
  font-size: 15px;
  margin-bottom: 10px;
}

img.profilePic {
  /* height: 100px; */
}

.gameStatus {
  padding-bottom: 10px;
}

.ui.vertically.divided.grid {
  margin-top: 1rem;
}

.navbar {
  padding-bottom: 1rem;
}

.ui.inverted.segment,
.ui.active.transition.visible.dimmer .ui.primary.inverted.segment {
  background: unset !important;
  /* color: rgba(255,255,255,.9); */
}

.ui.active.transition.visible.dimmer {
  background: unset;
}

img.logo {
  height: 75px;
}

/* i.flag {
  height: 2px !important;
  width: 2px !important;
} */

i.flag:not(.icon) {
  /* display: inline-block;
  width: 16px;
  height: 11px;
  line-height: 11px;
  vertical-align: baseline; */
  /* margin: 0.3em 2em 0 0.9em !important; */
  /* text-decoration: inherit;
  speak: none;
  font-smoothing: antialiased;
  -webkit-backface-visibility: hidden;
  backface-visibility: hidden; */
}

i.flag:not(.icon):before {
  /* width: 10px;
  height: 8px; */
}

.number,
g.tick.text {
  font-family: Inconsolata !important;
}
g.tick.text {
  opacity: 0.5;
}

h5.number {
  font-family: Inconsolata !important;
  font-weight: 500;
  /* font-size: 0.9rem; */
}

circle.dot {
  stroke: var(--gold);
  fill: var(--gold);
  stroke-width: 0.5px;
  stroke-opacity: 0.8;
}

.profileName {
  font-size: 20px;
}

img.profilePic {
  width: 75px;
}

h5.profileName {
  text-align-last: center;
}

.league {
  text-transform: uppercase;
  /* font-weight: bold; */
  margin-top: 5px;
  margin-bottom: 0px;
}

/* .leagueContainer {
  position: relative;
  text-align: center;
}

.leagueRank {
  position: absolute;
  top: 40px;
  left: 50px;
  color: #fff !important;
  text-shadow: 1px 0 0 #000, 0 -1px 0 #000, 0 1px 0 #000, -1px 0 0 #000 !important;
} */

.row.middleprofilediv {
  margin-top: 10px;
}

span.false {
  background: red;
  color: white;
  padding: 2px;
  font-weight: 800;
}

span.true {
  background: green;
  color: white;
  padding: 2px;
  font-weight: 800;
}

.playerMMrstat {
  /* margin-top: 25px; */
  /* font-size: 21px; */
  /* text-align: center; */

  -webkit-animation: fadeinout ease 10s infinite; /* Safari, Chrome and Opera > 12.1 */
  -moz-animation: fadeinout ease 10s infinite; /* Firefox < 16 */
  -ms-animation: fadeinout ease 10s infinite; /* Internet Explorer */
  -o-animation: fadeinout ease 10s infinite; /* Opera < 12.1 */
  animation: fadeinout ease 10s infinite;
  /* color: red;
  background: red; */
}

@keyframes fadeinout {
  0% {
    opacity: 0;
  }
  10% {
    opacity: 1;
  }
  90% {
    opacity: 1;
  }
  100% {
    opacity: 0;
  }
}

.match {
  -webkit-animation: fadein ease 10s; /* Safari, Chrome and Opera > 12.1 */
  -moz-animation: fadein ease 10s; /* Firefox < 16 */
  -ms-animation: fadein ease 10s; /* Internet Explorer */
  -o-animation: fadein ease 10s; /* Opera < 12.1 */
  animation: fadein ease 10s;
}

.table {
  background-image: url(https://github.com/w3champions/website/blob/d9eb0ddbab4f8493346434cdede16294ea3fccb6/public/assets/backgrounds/undead.jpg?raw=true) !important;
}

.compactTable {
  background-image: unset !important;
}

@keyframes fadein {
  0% {
    opacity: 0;
  }
  50% {
    opacity: 1;
  }
  100% {
    opacity: 1;
  }
}

.name {
  -webkit-animation: fadeinname ease 10s; /* Safari, Chrome and Opera > 12.1 */
  -moz-animation: fadeinname ease 10s; /* Firefox < 16 */
  -ms-animation: fadeinname ease 10s; /* Internet Explorer */
  -o-animation: fadeinname ease 10s; /* Opera < 12.1 */
  animation: fadeinname ease 10s;
}

@keyframes fadeinname {
  0% {
    opacity: 0;
  }
  10% {
    opacity: 1;
  }
  90% {
    opacity: 1;
  }
  100% {
    opacity: 0;
  }
}

.numberCircle {
  font-weight: bolder;
}

.sixteen.wide.column.playerName {
  padding-top: 3px !important;
}

.three.column.row.playerBottom {
  padding-top: 5px !important;
}

.ui.toggle.checkbox input:focus:checked ~ .box:before,
.ui.toggle.checkbox input:focus:checked ~ .coloring.black:before,
.ui.toggle.checkbox input:checked ~ .box:before,
.ui.toggle.checkbox input:checked ~ .coloring.black:before {
  background: red !important;
}

.ui.toggle.checkbox input:focus:checked ~ .coloring.white:before,
.ui.toggle.checkbox input:checked ~ .coloring.white:before {
  background: yellow !important;
}

.pulsating-circle {
  position: absolute;
  /* left: 50%; */
  /* top: 50%; */
  /* transform: translateX(-50%) translateY(-50%); */
  width: 15px;
  height: 15px;
  float: right;
}

.pulsating-circle:after {
  content: "";
  position: absolute;
  display: inline-block;
  left: 0;
  top: 0;
  display: block;
  width: 100%;
  height: 100%;
  background-color: red;
  border-radius: 15px;
  box-shadow: 0 0 8px rgba(0, 0, 0, 0.3);
  animation: pulse-dot 1.25s cubic-bezier(0.455, 0.03, 0.515, 0.955) -0.4s infinite;
}

@keyframes pulse-ring {
  0% {
    transform: scale(0.33);
  }
  80%,
  100% {
    opacity: 0;
  }
}

@keyframes pulse-dot {
  0% {
    transform: scale(0.8);
  }
  50% {
    transform: scale(1);
  }
  100% {
    transform: scale(0.8);
  }
}

#wrapper {
  border: 1px solid blue;
}

#div1 {
  display: inline-block;
  width: 120px;
  height: 120px;
  border: 1px solid red;
}
#div2 {
  display: inline-block;
  width: 160px;
  height: 160px;
  border: 1px solid green;
}

.timeDiv {
  /* float: right; */
  /* display: inline-block; */
}

.pulsating-circle {
  padding-top: 10px !important;
  margin-top: 2px;
  margin-left: 30px;
}

p.mapLabel {
  margin-left: -20px;
  margin-right: -20px;
}

.tableContainer {
  display: flex;
  justify-content: center;
}

.ui.vertically.divided.grid.team-header {
  border-top-left-radius: 7px;
  border-top-right-radius: 7px;
}

.ui.vertically.divided.grid.playerCard:nth-of-type(5) {
  border-bottom-left-radius: 7px;
  border-bottom-right-radius: 7px;
}

/* .playerName {
  font-family: "Roboto Bold";
  font-size: 1.15rem !important;
  font-weight: 800;
} */

.number {
  /* font-size: 1.15rem !important; */
}

td {
  /* min-width: 160px; */
}

.map-icon {
  width: 150px;
  height: 150px;
}

.profile-pic {
  width: 60px;
}

.matchDetails {
  width: max-content;
}

.red-text {
  color: var(--red);
}

td.yellow-text.number.team-0 {
  color: #fffdd0;
}

.green-text {
  color: var(--green);
}

h2 {
  color: var(--gold) !important;
  /* font-family: "OPTI-bold"; */
  font-size: 1.5rem !important;
}

.th-center {
  text-align: center !important;
}
.th {
  width: 100px;
}

.td {
}

.number {
  font-family: "Inconsolata" !important;

  font-size: large !important;
  font-weight: bolder !important;
}

.team-0 {
  text-align: right !important;
}

.team-1 {
  text-align: left !important;
}

.key {
  color: var(--grey);
  text-transform: uppercase;
}

.value {
  color: white;
}

.hero-pic {
  margin-right: 5px;
  flex: 0 0 auto;
  width: 35px;
  height: 35px;
}

.hero-bit .team-0 {
  float: right;
}

.hero-bit team-1 {
  float: left;
}

.matchDetails {
  position: relative;
}

.matchDetails > div {
  position: relative;
  z-index: 1; /* or any value less than the z-index of .matchDetails */
}

.matchDetails::before {
  content: "";
  position: absolute;
  opacity: 0.3;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: url(https://github.com/w3champions/website/blob/d9eb0ddbab4f8493346434cdede16294ea3fccb6/public/assets/backgrounds/undead.jpg?raw=true) !important;
  background-size: cover;
  z-index: -1;
}

.matchDetails > div {
  background-color: transparent;
}

.matchDetails .ui.segment table td {
  background-color: transparent !important;
}

.ui.segment {
  opacity: 0.75;
}

.ui.segment .profile-pic,
.ui.segment .text {
  opacity: 1;
}

/*  */

p.number.heroLevel {
  line-height: 1rem;
}

.flag {
  top: 5px !important;
}

.flag.team-0 {
  right: 5px !important;
  margin-right: 0px !important;
}

.flag.team-1 {
  left: 5px !important;
  margin-left: 0px !important;
}

path.line {
  stroke: white;
  stroke-width: 1.5 px;
}

line.line.team-middle {
  stroke: var(--grey);
  stroke-width: 0.5px;
}

img.race {
  margin-bottom: -7px;
  width: 35px !important;
}

.Game {
  padding-bottom: 75px;
}

table.ui.small.inverted.basic.compact.table {
  border: 2px solid grey;
  table-layout: auto;
  width: 150px;
}

.Game {
  /* padding: 70px; */
}

.max-width-cell {
  width: 100px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.live-indicator {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background-color: red;
  display: inline-block; /* Ensures it's displayed inline */
  vertical-align: middle; /* Vertically aligns it with the text */
  margin-left: 5px; /* Adjust the margin as needed */
  animation: pulse 1s infinite alternate;
  margin-bottom: 2px !important;
}

@keyframes pulse {
  from {
    transform: scale(1);
  }
  to {
    transform: scale(1.2);
  }
}

#PlayerProfile {
  /* background-color: magenta; */
}

.ui.table {
}

.playerDiv {
  width: 200px;
  /* overflow: hidden; */
}

.compact {
  width: 100px;
  overflow: hidden;
  background: rgba(0, 0, 0, 0);
}

.games {
  display: grid;
  place-items: center;
}

th {
  border: none !important;
}

.image-container {
  /* overflow-x: auto; */
  /* white-space: nowrap; */
}

.image-container {
  padding-top: 8px;
  margin-bottom: -10px;
}

img.mvpIconRight {
  padding-left: 10px;
}

img.mvpIconLeft {
  padding-right: 10px;
}
```

## File: src/App.js
```javascript
import React, { useState, useEffect } from "react";
import { Container, Grid, Dimmer, Loader, Divider } from "semantic-ui-react";

import Match from "./Match.js";
import Navbar from "./Navbar.js";

import { standardDeviation, arithmeticMean } from "./utils.js";

import "semantic-ui-css/semantic.min.css";
import "./App.css";

import { gameMode, gateway, season } from "./params";

const App = () => {
  const [matches, setMatches] = useState([]);
  const [ladderRanks, setLadderRanks] = useState([]);

  useEffect(() => {
    const loadData = async () => {
      try {
        var url = new URL("https://website-backend.w3champions.com/api/matches/ongoing");
        var params = {
          offset: 0,
          gateway,
          pageSize: 50,
          gameMode,
          map: "Overall",
        };
        url.search = new URLSearchParams(params).toString();

        var response = await fetch(url);
        var result = await response.json();
        let matches = result.matches;

        matches.forEach((m) => {
          let matchMmr = 0;
          m.teams.forEach((t) => {
            let playerMmrs = t.players.map((d) => d.oldMmr);
            let teamAverage = arithmeticMean(playerMmrs);
            let teamDeviation = standardDeviation(playerMmrs);
            t.teamAverage = teamAverage;
            t.teamDeviation = teamDeviation;
            matchMmr += teamAverage;
          });

          m.matchMmr = Math.round(matchMmr / 2);
        });

        matches.sort((a, b) => b.matchMmr - a.matchMmr);

        const pageUrl = new URL(window.location.href);
        const searchParams = new URLSearchParams(pageUrl.search);
        const queryParams = Object.fromEntries(searchParams);
        if (queryParams.player !== undefined) {
        }

        setMatches(matches);

        var url = new URL("https://website-backend.w3champions.com/api/ladder/0");
        var params = { gateway, season, gameMode };
        url.search = new URLSearchParams(params).toString();

        var response = await fetch(url);
        var result = await response.json();
        setLadderRanks(result.slice(0, 20));
      } catch (e) {
        console.log(e);
      }
    };
    loadData();
    let intervalId = setInterval(loadData, 30000);
    return () => clearInterval(intervalId);
  }, []);

  if (matches.length > 0 && ladderRanks.length > 0) {
    return (
      <Container>
        <>
          <Navbar />
        </>
        <div className="matches">
          {Object.keys(matches).map((key) => (
            <div>
              <Match match={matches[key]} key={matches[key].id} ladderRanks={ladderRanks} />
              <Divider />
            </div>
          ))}
        </div>
      </Container>
    );
  } else {
    return (
      <Container>
        <Navbar />
        <Grid columns={3}>
          <Grid.Row columns={3}>
            <Dimmer active>
              <Loader />
            </Dimmer>
          </Grid.Row>
        </Grid>
      </Container>
    );
  }
};

export default App;
// npm run dev
```

## File: src/App.test.js
```javascript
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});
```

## File: src/fakeData.js
```javascript
const fakeData = {
  map: "ferocity",
  id: "601d52137e9f54f8aa94431b",
  "original-ongoing-match-id": "bN0Fj4VHiM",
  durationInSeconds: 0,
  startTime: "2021-02-05T14:11:12.381+00:00",
  endTime: "0001-01-01T00:00:00+00:00",
  gameMode: 4,
  teams: [
    {
      players: [
        {
          race: 0,
          rndRace: null,
          oldMmr: 2253,
          currentMmr: 0,
          battleTag: "HuyaYumiko#4873",
          name: "HuyaYumiko",
          mmrGain: -2253,
          won: false,
          location: "AT",
          countryCode: "CN",
          country: null,
          twitch: "",
        },
        {
          race: 0,
          rndRace: null,
          oldMmr: 2197,
          currentMmr: 0,
          battleTag: "RTGOD#2220",
          name: "RTGOD",
          mmrGain: -2197,
          won: false,
          location: "DE",
          countryCode: "DE",
          country: null,
          twitch: "weakudwc3",
        },
        {
          race: 8,
          rndRace: null,
          oldMmr: 1776,
          currentMmr: 0,
          battleTag: "Mendi#21932",
          name: "Mendi",
          mmrGain: -1776,
          won: false,
          location: "SI",
          countryCode: "JM",
          country: null,
          twitch: "",
        },
        {
          race: 1,
          rndRace: null,
          oldMmr: 1767,
          currentMmr: 0,
          battleTag: "ChefKAYDI#2946",
          name: "ChefKAYDI",
          mmrGain: -1767,
          won: false,
          location: "FR",
          countryCode: null,
          country: null,
          twitch: null,
        },
      ],
      won: false,
    },
    {
      players: [
        {
          race: 0,
          rndRace: null,
          oldMmr: 2140,
          currentMmr: 0,
          battleTag: "StarBuck#2732",
          name: "StarBuck",
          mmrGain: -2140,
          won: false,
          location: "SI",
          countryCode: "SI",
          country: null,
          twitch: "starbuck",
        },
        {
          race: 2,
          rndRace: null,
          oldMmr: 2073,
          currentMmr: 0,
          battleTag: "ic3#21532",
          name: "ic3",
          mmrGain: -2073,
          won: false,
          location: "DE",
          countryCode: null,
          country: null,
          twitch: null,
        },
        {
          race: 0,
          rndRace: null,
          oldMmr: 1995,
          currentMmr: 0,
          battleTag: "lmao#21922",
          name: "lmao",
          mmrGain: -1995,
          won: false,
          location: "NL",
          countryCode: "HM",
          country: null,
          twitch: "",
        },
        {
          race: 0,
          rndRace: null,
          oldMmr: 1738,
          currentMmr: 0,
          battleTag: "Signspree#2824",
          name: "Signspree",
          mmrGain: -1738,
          won: false,
          location: "CZ",
          countryCode: null,
          country: null,
          twitch: null,
        },
      ],
      won: false,
    },
  ],
  gateWay: 20,
  season: 0,
  number: null,
  serverInfo: { provider: "BNET", nodeId: null, countryCode: null, location: null, name: null, playerServerInfos: [] },
};

export default fakeData;
```

## File: src/FinishedGame.js
```javascript
import React, { useState, useEffect } from "react";
import { Container, Dimmer, Loader } from "semantic-ui-react";
import Navbar from "./Navbar.js";
import Game from "./Game.js";
import { preprocessPlayerScores, calcPlayerMmrAndChange } from "./utils.js";
import { getPlayerCountry, fetchMMRTimeline, getPlayerProfilePicUrl } from "./utils.js";
import { gameMode, gateway, season } from "./params.js";

const FinishedGame = ({ data }) => {
  console.log("data", data);
  const [playerData, setPlayerData] = useState(null);
  // const [scoreScreenData, setScoreScreenData] = useState(null);
  const [metaData, setMetaData] = useState(null);
  const [profilePics, setProfilePics] = useState({});
  const [mmrTimeline, setMmrTimeline] = useState({});
  const [playerCountries, setPlayerCountries] = useState({});
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    fetchMatchData();
  }, []);

  const fetchMatchData = async () => {
    try {
      const processedData = preprocessMatchData(data);
      const { playerData, metaData } = { ...processedData };
      console.log("playerData", playerData);
      console.log("metaData", metaData);

      setPlayerData(playerData);
      setMetaData(metaData);
      await fetchPlayerData(playerData);
    } catch (error) {
      console.error("Error fetching match data:", error.message);
      setIsLoading(false);
    }
  };

  const preprocessMatchData = (matchData) => {
    console.log("matchData", matchData);
    if (!matchData) {
      // || !matchData.match || !matchData.playerScores
      throw new Error("Invalid match data format");
    }
    return preprocessPlayerScores(matchData.match, matchData.playerScores);
  };

  const fetchPlayerData = async (processedData) => {
    console.log("FINISHED GAME const fetchPlayerData", processedData);
    setIsLoading(true);
    try {
      const promises = processedData.map(async (playerData) => {
        const { battleTag } = playerData;
        const [profilePicUrl, mmrTimelineData, country] = await Promise.all([getPlayerProfilePicUrl(battleTag), fetchMMRTimeline(battleTag, playerData.race), getPlayerCountry(battleTag)]);
        return {
          ...playerData,
          profilePicUrl,
          mmrTimelineData,
          country,
        };
      });
      const updatedData = await Promise.all(promises);
      let profilePics = updatedData.reduce((acc, curr) => {
        acc[curr.battleTag] = curr.profilePicUrl;
        return acc;
      }, {});
      console.log("profilePics", profilePics);
      setProfilePics(profilePics);
      setMmrTimeline(
        updatedData.reduce((acc, curr) => {
          acc[curr.battleTag] = curr.mmrTimelineData;
          return acc;
        }, {})
      );
      setPlayerCountries(
        updatedData.reduce((acc, curr) => {
          acc[curr.battleTag] = curr.country;
          return acc;
        }, {})
      );
    } catch (error) {
      console.error("Error fetching player data:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <>
      {isLoading ? (
        <Dimmer active>
          <Loader size="large">Loading match data...</Loader>
        </Dimmer>
      ) : playerData ? (
        <Game playerData={playerData} metaData={metaData} profilePics={profilePics} mmrTimeline={mmrTimeline} playerCountries={playerCountries} />
      ) : (
        <div>Error: Failed to load match data</div>
      )}
    </>
  );
};

export default FinishedGame;
```

## File: src/FinishedGamePage.js
```javascript
import React, { useState, useEffect } from "react";
import { Container, Dimmer, Loader } from "semantic-ui-react";
import Navbar from "./Navbar.js";
import Game from "./Game.js";
import { preprocessPlayerScores, calcPlayerMmrAndChange } from "./utils.js";
import { getPlayerCountry, fetchMMRTimeline, getPlayerProfilePicUrl } from "./utils.js";
import { gameMode, gateway, season } from "./params.js";
import FinishedGame from "./FinishedGame.js";

const extractMatchIdFromUrl = () => {
  const pageUrl = new URL(window.location.href);
  return pageUrl.pathname.split("/").slice(-1)[0];
};

const FinishedGamePage = () => {
  const [data, setData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);

  const getMatchData = async (matchId) => {
    const url = `https://website-backend.w3champions.com/api/matches/${matchId}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error("Failed to fetch match data");
    }
    return response.json();
  };

  useEffect(() => {
    fetchMatchData();
  }, []);

  const fetchMatchData = async () => {
    try {
      const matchId = extractMatchIdFromUrl();
      const data = await getMatchData(matchId);
      console.log("data", data);
      setData(data);
      setIsLoading(false);

      //   setMetaData(metaData);
      //   await fetchPlayerData(playerData);
    } catch (error) {
      console.error("Error fetching match data:", error.message);
      setIsLoading(false);
    }
  };

  return (
    <>
      {isLoading ? (
        <Dimmer active>
          <Loader size="large">Loading match data...</Loader>
        </Dimmer>
      ) : data ? (
        <FinishedGame data={data} />
      ) : (
        <div>Error: Failed to load match data</div>
      )}
    </>
  );
};

export default FinishedGamePage;
```

## File: src/Game.js
```javascript
import React, { useState, useEffect } from "react";
import { Flag, Table } from "semantic-ui-react";
import * as d3 from "d3";
import { Sparklines, SparklinesLine, SparklinesSpots } from "react-sparklines";
import { Link } from "react-router-dom";

import { MmrComparison } from "./MmrComparison.js";
import { MmrTrend } from "./MmrTrend.js";
import { calculatePercentiles, calculateElapsedTime, convertToLocalTime } from "./utils.js";
import human from "./icons/human.svg";
import orc from "./icons/orc.svg";
import elf from "./icons/elf.svg";
import undead from "./icons/undead.svg";
import random from "./icons/random.svg";
import king from "./icons/king.svg";
import medal from "./icons/medal.svg";

const Game = ({ playerData, metaData, profilePics, mmrTimeline, playerCountries, compact }) => {
  console.log("Game", "compact", compact);
  const excludedKeys = ["mercsHired", "itemsObtained", "lumberCollected"];
  const raceMapping = { 8: undead, 0: random, 4: elf, 2: orc, 1: human };
  playerData = [...playerData.slice(0, 4).reverse(), ...playerData.slice(4)];

  const keyDisplayNameMapping = {
    heroesKilled: "Heroes Killed",
    expGained: "Experience Gained",
    goldCollected: "Gold Mined",
    unitsProduced: "Units Produced",
    unitsKilled: "Units Killed",
    largestArmy: "Largest Army",
    lumberCollected: "Lumber Harvested",
    goldUpkeepLost: "Gold Lost to Upkeep",
  };

  const calculatePercentiles = (arr) => {
    // console.log(arr);
    // Sort the array in ascending order
    const sortedArr = arr.slice().sort((a, b) => a - b);
    const n = sortedArr.length;

    // Calculate percentile for each element
    const percentiles = arr.map((num) => {
      // Find the index of the number in the sorted array
      const index = sortedArr.indexOf(num);

      // Calculate percentile using index and array length
      const percentile = (index / (n - 1)) * 100;
      return percentile;
    });
    // console.log(percentiles);
    return percentiles;
  };

  const getCellStyle = (percentile) => {
    let className = "white-text"; // Default color

    if (percentile >= 90) {
      className = "green-text"; // Top 20%
    } else if (percentile >= 25) {
      className = "white-text"; // Middle 60%
    } else {
      className = "red-text"; // Bottom 20%
    }
    // console.log("percentile", percentile, className);

    return className;
  };

  const renderTableCells = (scoreType, statName, teamIndex, percentiles) => {
    // Determine which team's total to use
    // console.log("renderTableCells");
    // console.log(scoreType, statName, teamIndex, percentiles);

    // Render table cells for each player in the team
    return playerData.slice(teamIndex * 4, (teamIndex + 1) * 4).map((playerScore, index) => {
      // console.log("index", teamIndex * 4 + index);
      // Determine the cell's style based on the player's value
      const value = playerScore[scoreType][statName];
      // console.log("value", value);
      // console.log(percentiles[index]);
      const className = getCellStyle(percentiles[teamIndex * 4 + index]);
      return (
        <Table.Cell key={`team${teamIndex + 1}-${index}`} className={`${className} number team-${teamIndex}`}>
          {value.toLocaleString("en-US")}
        </Table.Cell>
      );
    });
  };

  const renderTableRows = (scoreType) => {
    if (!playerData[0].unitScore) {
      return <></>;
    }
    return Object.entries(playerData[0][scoreType])
      .filter(([statName]) => !excludedKeys.includes(statName)) // Exclude keys specified in excludedKeys
      .map(([statName, _]) => {
        // Extract the scores for the current statName from all players
        const scores = playerData.map((player) => player[scoreType][statName]);

        // Calculate percentiles for the scores
        let percentiles = calculatePercentiles(scores);

        // If the statName is "goldUpkeepLost", reverse the percentiles
        if (statName === "goldUpkeepLost") {
          percentiles = percentiles.map((d) => 100 - d);
        }

        // Render the table row
        return (
          <Table.Row key={statName}>
            {renderTableCells(scoreType, statName, 0, percentiles)}
            <Table.Cell className="th-center key">{keyDisplayNameMapping[statName] || statName}</Table.Cell>
            {renderTableCells(scoreType, statName, 1, percentiles)}
          </Table.Row>
        );
      });
  };

  const renderHero = (hero, teamIndex) => {
    if (!playerData[0].heroes) {
      return <></>;
    }
    return (
      <div style={{ float: `${teamIndex == 0 ? "right" : "left"}`, textAlign: "center" }}>
        <img src={`${process.env.PUBLIC_URL}/heroes/${hero.icon}.jpeg`} alt="Hero Icon" className="hero-pic" />
        <p className="number heroLevel">{hero.level}</p>
      </div>
    );
  };

  const renderHeroRows = () => {
    if (!playerData[0].heroScore) {
      return <></>;
    }
    return (
      <Table.Row>
        {playerData.slice(0, 4).map((playerScore, index) => (
          <Table.Cell key={`team1-hero-${index}`} style={{ display: "table-cell" }}>
            <div className="team-0">
              {playerScore.heroes.map((hero, heroIndex) => (
                <div key={`team0-hero-${index}-${heroIndex}`} className="">
                  {renderHero(hero, 0)}
                </div>
              ))}
            </div>
          </Table.Cell>
        ))}
        <Table.Cell className="th-center key">Heroes</Table.Cell>

        {playerData.slice(4).map((playerScore, index) => (
          <Table.Cell key={`team2-hero-${index}`} style={{ display: "table-cell" }}>
            {playerScore.heroes.map((hero, heroIndex) => (
              <div key={`team1-hero-${index}-${heroIndex}`} className="">
                {renderHero(hero, 1)}
              </div>
            ))}
          </Table.Cell>
        ))}
      </Table.Row>
    );
  };

  const renderPlayerCell = (player, teamClassName) => {
    const { oldMmr, mmrChange } = { ...player };

    // Determine flag positioning based on team alignment
    const flagPosition = teamClassName === "team-0" ? { top: 0, right: 0 } : { top: 0, left: 0 };

    return (
      <Table.HeaderCell key={player.battleTag}>
        <div
          className={`${teamClassName} playerDiv ${compact ? "compact" : ""}`}
          style={{ position: "relative", float: teamClassName === "team-0" ? "right" : "left" }}
        >
          <div style={{ position: "relative" }}>
            {player.isMvp && teamClassName === "team-0" ? (
              <img src={medal} alt={"won"} className={"mvpIconLeft"} style={{ height: "50px" }} />
            ) : (
              ""
            )}
            {profilePics[player.battleTag] ? (
              <img src={profilePics[player.battleTag]} alt="Player Profile Pic" className="profile-pic " />
            ) : null}
            {playerCountries[player.battleTag] ? (
              <Flag
                name={playerCountries[player.battleTag].toLowerCase()}
                style={{ position: "absolute", ...flagPosition }}
                className={`${teamClassName} flag`}
              ></Flag>
            ) : null}
            {player.isMvp && teamClassName === "team-1" ? (
              <img src={medal} alt={"won"} className={"mvpIconRight"} style={{ height: "50px" }} />
            ) : (
              ""
            )}
          </div>
          <div>
            <Link to={`/player/${player.battleTag.replace("#", "%23")}`}>
              <h2>{player.name}</h2>
            </Link>
          </div>
          <div style={{ alignItems: "center", height: "100%", paddingTop: "5px", paddingBottom: "5px" }}>
            <img src={raceMapping[player.race]} alt={player.race} className={"race"} style={{ height: "30px" }} />
          </div>
          <div>
            <p className="key">
              <span className="number value">{oldMmr}</span> <span className="key">MMR</span>
              {mmrChange ? (
                <span className={"number"} style={{ color: mmrChange > 0 ? "green" : "red" }}>
                  {mmrChange}
                </span>
              ) : (
                <></>
              )}
            </p>
          </div>
          <div
            style={{
              width: "75px",
              height: "15px",
              overflow: "hidden",
              display: "inline-block",
              marginTop: "10px",
              float: teamClassName === "team-0" ? "right" : "left",
            }}
          >
            {" "}
            {/* <div> */}
            <Sparklines data={mmrTimeline[player.battleTag]} style={{ width: "130px", height: "14px" }}>
              <SparklinesLine style={{ strokeWidth: 4, stroke: "white", fill: "none" }} />
            </Sparklines>
            {/* <MmrTrend data={{ mmrTimeline: mmrTimeline[playerScore.battleTag] }} id={"123"} /> */}
          </div>
        </div>
      </Table.HeaderCell>
    );
  };

  return (
    <div className="Game">
      <Table inverted size="small" basic className={`${compact ? "compactTable" : ""}`}>
        <Table.Header>
          <Table.Row>
            <th> </th>
            <th> </th>
            <th className="team-0">
              {playerData[0].won ? <img src={king} alt={"won"} className={"race"} style={{ height: "50px" }} /> : ""}
            </th>
            <th className="team-0">
              <div>
                <h2>TEAM 1</h2>
                <p className="key" style={{ marginBottom: "0px", marginTop: "-10px" }}>
                  <span className="number value">
                    {Math.round(
                      playerData
                        .slice(0, 4)
                        .map((d) => d.oldMmr)
                        .reduce((acc, curr) => acc + curr, 0) / 4
                    )}
                  </span>{" "}
                  <span className="key">MMR</span>
                </p>
                <div className="image-container">
                  {playerData
                    .slice(0, 4)
                    .map((d) => d.race)
                    .sort((a, b) => b - a)
                    .map((race, i) => (
                      <img
                        key={i}
                        src={raceMapping[race]}
                        alt={race}
                        className={"race"}
                        style={{ paddingLeft: "5px", width: "30px" }}
                      />
                    ))}
                </div>
              </div>
            </th>
            <th className="th-center" style={{ position: "relative" }}>
              <h2>VS</h2>
            </th>
            <th className="team-1">
              <div>
                <h2>TEAM 2</h2>
                <p className="key" style={{ marginBottom: "0px", marginTop: "-10px" }}>
                  <span className="number value">
                    {Math.round(
                      playerData
                        .slice(4)
                        .map((d) => d.oldMmr)
                        .reduce((acc, curr) => acc + curr, 0) / 4
                    )}
                  </span>{" "}
                  <span className="key">MMR</span>
                </p>
                <div className="image-container">
                  {playerData
                    .slice(4)
                    .map((d) => d.race)
                    .sort((a, b) => b - a)
                    .map((race, i) => (
                      <img
                        key={i}
                        src={raceMapping[race]}
                        alt={race}
                        className={"race"}
                        style={{ paddingLeft: "0px", paddingRight: "5px", width: "35px" }}
                      />
                    ))}
                </div>
              </div>
            </th>
            <th className="team-01">
              {playerData[4].won ? <img src={king} alt={"won"} className={"race"} style={{ height: "50px" }} /> : ""}
            </th>
            <th> </th>
            <td> </td>
          </Table.Row>
        </Table.Header>
        <Table.Header>
          <Table.Row>
            {playerData.map((playerScore, index) => {
              const teamIndex = index < 4 ? 0 : 1;
              const teamClassName = `team-${teamIndex}`;
              return (
                <React.Fragment key={`player-${index}`}>
                  {renderPlayerCell(playerScore, teamClassName)}
                  {index === 3 && (
                    <th className={`th-center ${compact}`} style={{ position: "relative" }}>
                      <div style={{ height: "170px", overflow: "hidden", display: "inline-block" }}>
                        <MmrComparison
                          data={{
                            teamOneMmrs: playerData.slice(0, 4).map((d) => d.oldMmr),
                            teamTwoMmrs: playerData.slice(4).map((d) => d.oldMmr),
                          }}
                          id={"123"}
                        />
                      </div>
                    </th>
                  )}
                </React.Fragment>
              );
            })}
          </Table.Row>
        </Table.Header>

        <Table.Body>
          {!playerData[0].unitScore ? (
            <></>
          ) : (
            <>
              {renderHeroRows()}

              {renderTableRows("heroScore")}
              <Table.Row>
                <td> </td>
                <td> </td>
                <td> </td>
                <td> </td>
                <td> </td>
                <td> </td>
                <td> </td>
                <td> </td>
                <td> </td>
              </Table.Row>
              {renderTableRows("unitScore")}
              <Table.Row>
                <td> </td>
                <td> </td>
                <td> </td>
                <td> </td>
                <td> </td>
                <td> </td>
                <td> </td>
                <td> </td>
                <td> </td>
              </Table.Row>
              {renderTableRows("resourceScore")}
              <Table.Row>
                <td> </td>
                <td> </td>
                <td> </td>
                <td> </td>
                <td> </td>
                <td> </td>
                <td> </td>
                <td> </td>
                <td> </td>
              </Table.Row>
            </>
          )}
          <Table.Row className="meta">
            <td></td>
            <td> </td>
            <td className="th-center">
              <div>
                <div className="value">{metaData.location}</div>
                <div className="key">REGION</div>
              </div>
            </td>
            <td className="th-center">
              <div>
                <div className="value">{metaData.server}</div>
                <div className="key">SERVER</div>
              </div>
            </td>
            <td className="th-center">
              <div style={{ position: "relative", display: "inline-block" }}>
                <img
                  src={`${process.env.PUBLIC_URL}/maps/${metaData.mapName}.png`}
                  alt="map"
                  style={{ width: "100px", height: "100px", display: "block" }} // Adjust the size as needed
                />
                <img
                  src={`${process.env.PUBLIC_URL}/icons/Classic_Frame.png`}
                  alt="Frame"
                  style={{ position: "absolute", top: 0, left: 0, width: "100px", height: "100px" }} // Adjust size and position as needed
                />
              </div>
              <div className="value">{metaData.mapName}</div>
              <div className="key">MAP</div>
            </td>
            <td className="th-center">
              <div>
                <div className="value">
                  {metaData.gameLength === "0:00"
                    ? calculateElapsedTime(metaData.startTime) + " MINS"
                    : metaData.gameLength + " MINS"}
                  {metaData.gameLength === "0:00" && <div className="live-indicator"></div>}
                </div>
                <div className="key">GAME LENGTH</div>
              </div>
            </td>
            <td className="th-center">
              <div>
                <div className="value">{convertToLocalTime(metaData.startTime)}</div>
                <div className="key">DATETIME</div>
              </div>
            </td>
            <td> </td>
            <td> </td>
          </Table.Row>
        </Table.Body>
      </Table>
    </div>
  );
};

export default Game;
```

## File: src/index.css
```css
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}
```

## File: src/index.js
```javascript
import React from "react";
import { createRoot } from "react-dom/client"; // Import createRoot from "react-dom/client"
import Router from "./Router";

import "./index.css";

createRoot(document.getElementById("root")).render(<Router />);
```

## File: src/Ladder.js
```javascript
import React, { Component } from "react";
import Navbar from "./Navbar.js";
import RankRow from "./RankRow.js";

import { Container, Flag, Header, Table, Rating } from "semantic-ui-react";

import { gateway, season } from "./params";

class Ladder extends Component {
  state = {
    rankings: [],
  };

  componentDidMount() {
    this.loadData();
    this.setState({}); //intervalId
  }

  componentWillUnmount() {}

  loadData = async () => {
    try {
      var url = new URL(
        `https://website-backend.w3champions.com/api/ladder/0?gateWay=20&gameMode=4&season=${season}`
      );
      var response = await fetch(url);
      var result = await response.json();
      this.setState({ rankings: result });
    } catch (e) {
      console.log(e);
    }
  };

  render() {
    const rankings = this.state.rankings;
    if (rankings.length > 0) {
      return (
        <Container>
          <Navbar />
          <div className={"tableContainer"}>
            <Table inverted size="small" compact>
              <Table.Header>
                <Table.Row>
                  <Table.HeaderCell singleLine>Rank</Table.HeaderCell>
                  <Table.HeaderCell>LVL</Table.HeaderCell>
                  <Table.HeaderCell>Race</Table.HeaderCell>
                  <Table.HeaderCell>Player</Table.HeaderCell>
                  <Table.HeaderCell>MMR</Table.HeaderCell>
                  <Table.HeaderCell>Wins</Table.HeaderCell>
                  <Table.HeaderCell>Losses</Table.HeaderCell>
                  <Table.HeaderCell>Winrate</Table.HeaderCell>
                  <Table.HeaderCell>Form</Table.HeaderCell>
                </Table.Row>
              </Table.Header>

              <Table.Body>
                {Object.keys(rankings).map((key) => (
                  <RankRow
                    rank={rankings[key]}
                    key={rankings[key].id}
                  ></RankRow>
                ))}
              </Table.Body>
            </Table>
          </div>
        </Container>
      );
    } else {
      return (
        <Container>
          <Navbar />
        </Container>
      );
    }
  }
}

export default Ladder;
```

## File: src/LineGraphPlotSection.js
```javascript
import React, { Component } from "react";

import LineGraphPlot from "./charts/LineGraphPlot";
// import RangePlot from "./charts/RangePlot";

class LineGraphPlotSection extends Component {
  componentDidMount() {
    this.draw();
  }

  draw = () => {
    if (this.props.data != null && this.props.data !== []) {
      //   LineGraphPlot(`rangeplot-${this.props.id}`, this.props.data);
    }
  };

  render() {
    return <div id={`rangeplot-0`}></div>;
  }
}

export default LineGraphPlotSection;
```

## File: src/Match.js
```javascript
// import React, { useState, useEffect } from "react";
// import Team from "./Team.js";
// import MatchHeader from "./MatchHeader.js";
// import RangePlotSection from "./RangePlotSection.js";
// import * as d3 from "d3";
// import { Grid } from "semantic-ui-react";
// import { gameMode, gateway } from "./params";

// const Match = ({ match, battleTag, render, sparklinePlayersData, ladderRanks }) => {
//   const [isChecked, setIsChecked] = useState(false);
//   const [intervalId, setIntervalId] = useState(null);
//   const [ongoing, setOngoing] = useState(true);
//   const [mmrsGathered, setMmrsGathered] = useState([]);
//   const [allMmrsgathered, setAllMmrsgathered] = useState(false);
//   const [transitionId, setTransitionId] = useState(null);
//   const [transition, setTransition] = useState(false);

//   useEffect(() => {
//     return () => {
//       clearInterval(intervalId);
//       clearInterval(transitionId);
//     };
//   }, [intervalId, transitionId]);

//   const toggleChange = () => {
//     setIsChecked(!isChecked);
//     if (intervalId === null) {
//       let newIntervalId = setInterval(getGameData, 1000);
//       setIntervalId(newIntervalId);
//     } else {
//       clearInterval(intervalId);
//     }
//   };

//   const noteApiAttempted = (id) => {
//     let newMmrsGathered = [...mmrsGathered, id];
//     let newAllMmrsgathered = allMmrsgathered;
//     let newTransitionId = transitionId;
//     if (newMmrsGathered.length === 8) {
//       newAllMmrsgathered = true;
//       newTransitionId = setInterval(() => setTransition(!transition), 10000);
//     }
//     setMmrsGathered(newMmrsGathered);
//     setAllMmrsgathered(newAllMmrsgathered);
//     setTransitionId(newTransitionId);
//   };

//   const getGameData = async () => {
//     if (!ongoing) return;

//     const matchId = match.id;
//     const urlLive = new URL("https://website-backend.w3champions.com/api/matches/ongoing");
//     const params = {
//       offset: 0,
//       gateway,
//       pageSize: 50,
//       gameMode,
//       map: "Overall",
//     };
//     urlLive.search = new URLSearchParams(params).toString();

//     try {
//       const response = await fetch(urlLive);
//       const result1 = await response.json();
//       const matches = result1.matches;

//       const filteredMatch = matches.filter((d) => d.id === matchId);
//       if (filteredMatch.length === 0) {
//         setOngoing(false);
//         // toast("Game finished!", { icon: "" });
//         // const audio = new Audio("https://notificationsounds.com/storage/sounds/file-sounds-1348-ill-make-it-possible.mp3");
//         // audio.play();
//       }
//     } catch (error) {
//       console.log(error);
//     }
//   };

//   const teamOnePlayers = match.teams[0].players.map((d) => d.battleTag);
//   const teamOne = teamOnePlayers.includes(battleTag) ? match.teams[0] : match.teams[1];
//   const teamTwo = teamOnePlayers.includes(battleTag) ? match.teams[1] : match.teams[0];
//   const teamOneMmrs = teamOne.players.map((d) => d.oldMmr);
//   const teamTwoMmrs = teamTwo.players.map((d) => d.oldMmr);
//   const teamOneAverageMmr = teamOne.teamAverage;
//   const teamTwoAverageMmr = teamTwo.teamAverage;
//   const gameMmr = Math.round((teamOneAverageMmr + teamTwoAverageMmr) / 2);
//   const threshold = d3.scaleThreshold().domain([1000, 1200, 1300, 1400, 1500, 1600, 1700]).range(["grass", "bronze", "silver", "gold", "platinum", "diamond", "adept", "master", "grandmaster"]);
//   const league = threshold(gameMmr);
//   const data = {
//     teamOneMmrs,
//     teamOneAverageMmr,
//     teamTwoMmrs,
//     teamTwoAverageMmr,
//     league,
//   };
//   const startDate = new Date(match.startTime);
//   const map = match.mapName;
//   const matchOngoing = match.durationInSeconds === 0;

//   return (
//     <div className="match">
//       <Grid columns={3}>
//         <Grid.Column />
//         <Grid.Column>{render === false ? <div /> : <MatchHeader id={match.id} league={league} startDate={startDate} map={map} ongoing={matchOngoing} durationInSeconds={match.durationInSeconds} />}</Grid.Column>
//         <Grid.Column />

//         <Grid.Row columns={3}>
//           <Grid.Column width={6}>
//             <Team
//               team={teamOne}
//               teamNum={1}
//               teamAverage={teamOneAverageMmr}
//               teamDeviation={teamOne.teamDeviation}
//               side="left"
//               transition={transition}
//               sparklinePlayersData={sparklinePlayersData}
//               ladderRanks={ladderRanks}
//               noteApiAttempted={noteApiAttempted}
//               transitionId={transitionId}
//               allMmrsgathered={allMmrsgathered}
//             />
//           </Grid.Column>
//           <Grid.Column width={4}>
//             <RangePlotSection data={data} id={match.id} />
//           </Grid.Column>
//           <Grid.Column width={6}>
//             <Team
//               team={teamTwo}
//               teamNum={2}
//               teamAverage={teamTwoAverageMmr}
//               teamDeviation={teamTwo.teamDeviation}
//               side="right"
//               transition={transition}
//               sparklinePlayersData={sparklinePlayersData}
//               ladderRanks={ladderRanks}
//               noteApiAttempted={noteApiAttempted}
//               transitionId={transitionId}
//               allMmrsgathered={allMmrsgathered}
//             />
//           </Grid.Column>
//         </Grid.Row>
//         {/* <div
//             className={"checkboxDiv"}
//             style={{ margin: "auto", paddingTop: "10px" }}
//           >
//             <Checkbox
//               toggle
//               // label={"notify me"}
//               defaultChecked={this.state.isChecked}
//               onChange={this.toggleChange}
//             />
//           </div> */}
//       </Grid>
//     </div>
//   );
// };

// export default Match;
```

## File: src/MatchHeader.js
```javascript
import React, { Component } from "react";
import { Grid, Statistic, Label, GridColumn } from "semantic-ui-react";

import { maps } from "./params";

import grandmaster from "./icons/grandmaster.png";
import adept from "./icons/adept.png";
import master from "./icons/master.png";
import diamond from "./icons/diamond.png";
import platinum from "./icons/platinum.png";
import gold from "./icons/gold.png";
import silver from "./icons/silver.png";
import bronze from "./icons/bronze.png";
import grass from "./icons/grass.png";
import goldrush from "./maps/goldrush.png";
import TwilightRuinsLV from "./maps/TwilightRuinsLV.png";
// import logo from "./logos/logo.svg";

class MatchHeader extends Component {
  render() {
    // const league = "grandmaster";
    const badgeMapping = {
      grandmaster: grandmaster,
      adept: adept,
      master: master,
      diamond: diamond,
      platinum: platinum,
      gold: gold,
      silver: silver,
      bronze: bronze,
      grass: grass,
      // inGame: logo,
    };

    const mapMapping = {
      goldrush: goldrush,
      TwilightRuinsLV: TwilightRuinsLV,
    };

    const leagueIcon = badgeMapping[this.props.league];
    const mapIcon = mapMapping[this.props.map];
    const map = maps.hasOwnProperty(this.props.map) ? maps[this.props.map] : this.props.map;
    let text = "";

    const startDate = this.props.startDate;
    if (this.props.ongoing) {
      if (startDate !== null) {
        let end = Date.now();
        let elapsed = end - startDate;
        let minutes = Math.floor(elapsed / 1000 / 60);
        if (minutes < 60 * 24) {
          text = `${minutes}'`;
        } else {
          text = `started ${startDate.toDateString()}`;
        }
      } else {
        text = "";
      }
    } else {
      let end = Date.now();
      let elapsed = end - startDate;
      let minutes = Math.floor(elapsed / 1000 / 60);

      text = `${startDate.toDateString()}`;
    }

    return (
      <Grid.Row style={{ paddingBottom: "14px" }}>
        <Grid.Column>
          <Grid.Row>
            <a target="_blank" href={`/match/${this.props.id}`} rel="noreferrer">
              <img src={leagueIcon} alt={this.props.league} className={"league"} />
            </a>
            <h2 className={"mapLabel"}>{map}</h2>
          </Grid.Row>
          <Grid.Row>
            {/* <Grid.Column>test</Grid.Column> */}
            <Grid.Column>
              <div className={"pulsating-circle"} />
              <p>{text}</p>
            </Grid.Column>
          </Grid.Row>
        </Grid.Column>
      </Grid.Row>
    );
  }
}

export default MatchHeader;
```

## File: src/Mmr.js
```javascript
import React, { Component } from "react";

class Mmr extends Component {
  render() {
    const oldMmr = this.props.data;

    if (oldMmr !== undefined) {
      return <p className={"number"}>{oldMmr.toLocaleString()}</p>;
    } else {
      return null;
    }
  }
}

export default Mmr;
```

## File: src/MmrComparison.js
```javascript
import React, { useEffect, useRef } from "react";
import * as d3 from "d3";

const MmrComparison = ({ data }) => {
  const { teamOneMmrs, teamTwoMmrs } = data;
  const svgRef = useRef(null);

  useEffect(() => {
    if (!svgRef.current) return;

    const svg = d3.select(svgRef.current);

    // Remove existing content to avoid appending multiple plots
    svg.selectAll("*").remove();

    // Get dimensions of parent container
    const parent = svgRef.current.parentElement;
    const width = parent.clientWidth;
    const height = parent.clientHeight;

    // Define margins
    const margin = { top: 5, right: 0, bottom: 5, left: 0 }; // Adjusted top margin
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;

    // Define scales
    const yScale = d3
      .scaleLinear()
      // .domain([Math.min(...teamOneMmrs, ...teamTwoMmrs), Math.max(...teamOneMmrs, ...teamTwoMmrs)])
      .domain([800, 2600])
      .range([innerHeight, margin.bottom]);

    // Draw Team One line and circles
    const teamOneLine = d3
      .line()
      .x((d, i) => innerWidth / 4 + margin.left)
      .y((d) => yScale(d));

    svg.append("path").datum(teamOneMmrs).attr("class", "line team-one").attr("d", teamOneLine);

    svg
      .selectAll(".dot-team-one")
      .data(teamOneMmrs)
      .enter()
      .append("circle")
      .attr("class", "dot dot-team-one")
      .attr("cx", innerWidth / 4 + margin.left)
      .attr("cy", (d) => yScale(d))
      .attr("r", 3)
      .attr("fill", "red");

    // Draw Team Two line and circles
    const teamTwoLine = d3
      .line()
      .x((d, i) => (3 * innerWidth) / 4 + margin.left)
      .y((d) => yScale(d));

    svg.append("path").datum(teamTwoMmrs).attr("class", "line team-two").attr("d", teamTwoLine);

    svg
      .selectAll(".dot-team-two")
      .data(teamTwoMmrs)
      .enter()
      .append("circle")
      .attr("class", "dot dot-team-two")
      .attr("cx", (3 * innerWidth) / 4 + margin.left)
      .attr("cy", (d) => yScale(d))
      .attr("r", 3)
      .attr("fill", "blue");

    const middleLine = innerWidth / 2 + margin.left;

    svg
      .append("line")
      .attr("class", "line team-middle")
      .attr("x1", middleLine)
      .attr("y1", 0 + 15)
      .attr("x2", middleLine)
      .attr("y2", innerHeight - 15);

    svg.append("text").attr("class", "axistitle").text("MMR").attr("x", middleLine).attr("y", innerHeight);
  }, [teamOneMmrs, teamTwoMmrs]);

  return <svg ref={svgRef} style={{ width: "100%", height: "100%" }}></svg>;
};

export { MmrComparison };
```

## File: src/MmrTrend.js
```javascript
import React, { useEffect, useRef } from "react";
import * as d3 from "d3";

const MmrTrend = ({ data }) => {
  // const { mmrTimeline, id } = data;
  // console.log("MmrTrend", mmrTimeline);
  // const svgRef = useRef(null);
  // useEffect(() => {
  //   if (!svgRef.current) return;
  //   const svg = d3.select(svgRef.current);
  //   // Remove existing content to avoid appending multiple plots
  //   svg.selectAll("*").remove();
  //   // Get dimensions of parent container
  //   const parent = svgRef.current.parentElement;
  //   const width = parent.clientWidth;
  //   const height = parent.clientHeight;
  //   // Define margins
  //   const margin = { top: 5, right: 0, bottom: 5, left: 0 }; // Adjusted top margin
  //   const innerWidth = width - margin.left - margin.right;
  //   const innerHeight = height - margin.top - margin.bottom;
  //   // Define scales
  //   const yScale = d3
  //     .scaleLinear()
  //     .domain([Math.min(...teamOneMmrs, ...teamTwoMmrs), Math.max(...teamOneMmrs, ...teamTwoMmrs)])
  //     .range([innerHeight, margin.bottom]);
  //   // Draw Team One line and circles
  //   const teamOneLine = d3
  //     .line()
  //     .x((d, i) => innerWidth / 4 + margin.left)
  //     .y((d) => yScale(d));
  //   svg.append("path").datum(teamOneMmrs).attr("class", "line team-one").attr("d", teamOneLine);
  //   svg
  //     .selectAll(".dot-team-one")
  //     .data(teamOneMmrs)
  //     .enter()
  //     .append("circle")
  //     .attr("class", "dot dot-team-one")
  //     .attr("cx", innerWidth / 4 + margin.left)
  //     .attr("cy", (d) => yScale(d))
  //     .attr("r", 3)
  //     .attr("fill", "red");
  //   // Draw Team Two line and circles
  //   const teamTwoLine = d3
  //     .line()
  //     .x((d, i) => (3 * innerWidth) / 4 + margin.left)
  //     .y((d) => yScale(d));
  //   svg.append("path").datum(teamTwoMmrs).attr("class", "line team-two").attr("d", teamTwoLine);
  //   svg
  //     .selectAll(".dot-team-two")
  //     .data(teamTwoMmrs)
  //     .enter()
  //     .append("circle")
  //     .attr("class", "dot dot-team-two")
  //     .attr("cx", (3 * innerWidth) / 4 + margin.left)
  //     .attr("cy", (d) => yScale(d))
  //     .attr("r", 3)
  //     .attr("fill", "blue");
  //   const middleLine = innerWidth / 2 + margin.left;
  //   svg
  //     .append("line")
  //     .attr("class", "line team-middle")
  //     .attr("x1", middleLine)
  //     .attr("y1", 0 + 15)
  //     .attr("x2", middleLine)
  //     .attr("y2", innerHeight - 15);
  //   svg
  //     .append("text")
  //     .attr("class", "axistitle")
  //     .text("MMR")
  //     .attr("x", middleLine)
  //     .attr("y", innerHeight - 10);
  // }, [teamOneMmrs, teamTwoMmrs]);
  // return <svg ref={svgRef} style={{ width: "100%", height: "100%" }}></svg>;
};

export { MmrTrend };
```

## File: src/MyStreamPage.js
```javascript
import React from "react";
import SeamlessBackground from "./SeamlessBackground";
import Game from "./Game";

const App = () => <SeamlessBackground>"FOALS"</SeamlessBackground>;

export default App;
```

## File: src/Navbar.js
```javascript
import React, { Component } from "react";
import { Link } from "react-router-dom";

import * as d3 from "d3";

import { Header, Divider, Grid } from "semantic-ui-react";

// import logo from "./logos/logo.svg";

class Navbar extends Component {
  render() {
    return (
      <div className="navbar">
        <Header as="h1" icon textAlign="center">
          <div id="logoAndText">
            {/* <img src={logo} alt={"asd"} className={"logo"} /> */}
            <Header.Content>4v4.GG</Header.Content>
          </div>
          <Grid divided="vertically">
            <Grid.Row columns={3}>
              <Grid.Column width={4}>
                <h3>
                  <Link to="/ongoing">Live Games</Link>
                </h3>
              </Grid.Column>
              <Grid.Column width={4}>
                <h3>
                  <Link to="/finished">Recently Finished Games</Link>
                </h3>
              </Grid.Column>
              <Grid.Column width={4}>
                <h3>
                  <Link to="/queue">Queue</Link>
                </h3>
              </Grid.Column>
              <Grid.Column width={4}>
                <h3>
                  <Link to="/ladder">Ladder</Link>
                </h3>
              </Grid.Column>
            </Grid.Row>
            <Grid.Row columns={1}>
              <Grid.Column></Grid.Column>
            </Grid.Row>
          </Grid>
        </Header>
        {/* <Divider /> */}
        {/* <Image centered size="large" src="https://react.semantic-ui.com/images/wireframe/centered-paragraph.png" /> */}
      </div>
    );
  }
}

export default Navbar;
```

## File: src/OngoingGame.js
```javascript
import React, { useState, useEffect } from "react";
import { Container, Dimmer, Loader } from "semantic-ui-react";
import Game from "./Game.js";
import { processOngoingGameData, getPlayerProfilePicUrl, fetchMMRTimeline, getPlayerCountry } from "./utils.js";
import { gameMode, gateway, season } from "./params";

const OnGoingGame = ({ ongoingGameData, compact }) => {
  console.log("OnGoingGame", "compact", compact);
  const [playerData, setPlayerData] = useState(null);
  const [metaData, setMetaData] = useState(null);
  const [profilePics, setProfilePics] = useState(null);
  const [mmrTimeline, setMmrTimeline] = useState({});
  const [playerCountries, setPlayerCountries] = useState({});

  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const processedData = preprocessMatchData(ongoingGameData);
    // console.log("XXX processedData", processedData);
    const { playerData, metaData } = { ...processedData };
    setPlayerData(playerData);
    setMetaData(metaData);
    fetchRemainingPlayerData(playerData);
  }, []);

  const preprocessMatchData = (ongoingGameData) => {
    if (!ongoingGameData) {
      throw new Error("Invalid match data format");
    }
    // Process ongoing game data into the desired format
    return processOngoingGameData(ongoingGameData);
  };

  const fetchRemainingPlayerData = async (processedData) => {
    // console.log("ONGOING GAME const fetchPlayerData", processedData);

    setIsLoading(true);
    try {
      const promises = processedData.map(async (playerData) => {
        const { battleTag } = playerData;
        const [profilePicUrl, mmrTimelineData, country] = await Promise.all([getPlayerProfilePicUrl(battleTag), fetchMMRTimeline(battleTag, playerData.race), getPlayerCountry(battleTag)]);
        return {
          ...playerData,
          profilePicUrl,
          mmrTimelineData,
          country,
        };
      });
      const updatedData = await Promise.all(promises);
      let profilePics = updatedData.reduce((acc, curr) => {
        acc[curr.battleTag] = curr.profilePicUrl;
        return acc;
      }, {});
      // console.log("profilePics", profilePics);

      setProfilePics(profilePics);
      setMmrTimeline(
        updatedData.reduce((acc, curr) => {
          acc[curr.battleTag] = curr.mmrTimelineData;
          return acc;
        }, {})
      );
      setPlayerCountries(
        updatedData.reduce((acc, curr) => {
          acc[curr.battleTag] = curr.country;
          return acc;
        }, {})
      );
    } catch (error) {
      console.error("Error fetching player data:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <>
      {isLoading ? (
        <Dimmer active>
          <Loader size="large">Loading match data...</Loader>
        </Dimmer>
      ) : playerData && profilePics ? (
        <div>
          <Game playerData={playerData} metaData={metaData} profilePics={profilePics} mmrTimeline={mmrTimeline} playerCountries={playerCountries} compact={compact} />
        </div>
      ) : (
        <div>
          Error: Failed to load match data
          {JSON.stringify(playerData)}
          {JSON.stringify(profilePics)}
        </div>
      )}
    </>
  );
};

export default OnGoingGame;
```

## File: src/OnGoingGames.js
```javascript
import React, { useState, useEffect } from "react";
import { Container, Dimmer, Loader } from "semantic-ui-react";
import Game from "./Game.js";
import Navbar from "./Navbar.js";
import OnGoingGame from "./OngoingGame.js";
import { calculateTeamMMR, getPlayerProfilePicUrl, fetchMMRTimeline, getPlayerCountry } from "./utils.js";
import { gameMode, gateway, season } from "./params";

const OnGoingGames = () => {
  const [ongoingGameData, setOngoingGameData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    fetchOngoingMatchesData();
  }, []);

  const fetchOngoingMatchesData = async () => {
    try {
      const response = await fetch(`https://website-backend.w3champions.com/api/matches/ongoing?offset=0&gateway=${gateway}&pageSize=50&gameMode=${gameMode}&map=Overall&sort=startTimeDescending`);
      if (!response.ok) {
        throw new Error("Failed to fetch ongoing matches data");
      }
      const data = await response.json();
      const sortedMatches = data.matches.slice().sort((a, b) => {
        const teamAMMR = calculateTeamMMR(a.teams);
        const teamBMMR = calculateTeamMMR(b.teams);
        return teamBMMR - teamAMMR;
      });
      setOngoingGameData(sortedMatches);

      setIsLoading(false);
    } catch (error) {
      console.error("Error fetching match data:", error.message);
      setIsLoading(false);
    }
  };

  return (
    <>
      {isLoading ? (
        <Dimmer active>
          <Loader size="large">Loading match data...</Loader>
        </Dimmer>
      ) : ongoingGameData ? (
        <div>
          <Navbar />
          <div className="games">
            {ongoingGameData.map((d) => (
              <OnGoingGame ongoingGameData={d} key={d.id} />
            ))}
          </div>
        </div>
      ) : (
        <div>
          Error: Failed to load match data
          <p>{JSON.stringify(ongoingGameData)}</p>
        </div>
      )}
    </>
  );
};

export default OnGoingGames;
```

## File: src/params.js
```javascript
export const gameMode = 4;
export const gateway = 20;
export const season = 19;

export const maps = {
  s13TwilightRuinsLV: "Twilight Ruins",
  s13Ferocityv1_2: "Ferocity",
  s13WellspringTemplev1_2: "Wellspring Temple",
  s13EkrezemsMazev1_1: "Ekrezems Maze",
  s13Snowblindv1_2: "Snowblind",
  s13NorthshireLV: "Northshire",
  s13_1OrdealGroundv1_07: "Ordeal Ground",
  s13GoldRush: "Gold Rush",
  s13RoyalGardensv1_2: "Royal Gardens",
  s13NerubianPassage: "Nerubian Passage",
  s13PaintedWorld: "Painted World",
  s13Nightopia: "Nightopia",
  s13_1IndigoKeeperv1_1: "Indigo Keeper",
  s13DeadlockLV: "Deadlock",
};
```

## File: src/Player.js
```javascript
import React, { useState, useEffect } from "react";
import { Grid, Flag } from "semantic-ui-react";
import Mmr from "./Mmr.js";
import { Sparklines, SparklinesLine } from "react-sparklines";
import { akaLookup, raceLookup } from "./utils.js";
import human from "./icons/human.svg";
import orc from "./icons/orc.svg";
import elf from "./icons/elf.svg";
import undead from "./icons/undead.svg";
import random from "./icons/random.svg";

import { gameMode, gateway, season } from "./params";

const Player = ({ data, side, transition, allMmrsgathered }) => {
  const [sparklinePlayersData, setSparklinePlayersData] = useState([]);
  const { race, oldMmr, name, location, battleTag, rank } = data;
  const aka = akaLookup(name);
  const raceMapping = { 8: undead, 0: random, 4: elf, 2: orc, 1: human };
  const raceIcon = raceMapping[race];

  useEffect(() => {
    const fetchData = async () => {
      const player = data.battleTag.replace("#", "%23");
      const fetchURL = (url) => {
        return fetch(url).then((response) => {
          if (!response.ok) {
            throw new Error("Network response was not ok");
          }
          return response.json();
        });
      };

      try {
        const url1 = new URL(`https://website-backend.w3champions.com/api/players/${player}/mmr-rp-timeline`);
        const params1 = { gateway, season, race, gameMode: 4 };
        url1.search = new URLSearchParams(params1).toString();
        const result1 = await fetchURL(url1);
        const prevSeasonMMrs = result1.mmrRpAtDates
          .slice(1)
          .slice(-20)
          .map((d) => d.mmr);
        const url2 = new URL(`https://website-backend.w3champions.com/api/players/${player}/mmr-rp-timeline`);
        const params2 = { gateway, season, race, gameMode: 4 };
        url2.search = new URLSearchParams(params2).toString();
        const result2 = await fetchURL(url2);
        const thisSeasonMMrs = result2.mmrRpAtDates.map((d) => d.mmr);
        setSparklinePlayersData([...prevSeasonMMrs, ...thisSeasonMMrs]);
      } catch (error) {
        console.error("Error fetching player data:", error);
      }
    };

    fetchData();
  }, [data, race]);

  const PlayerMmrStatistic = () => {
    if (transition && sparklinePlayersData && sparklinePlayersData.length > 0) {
      return (
        <Sparklines data={sparklinePlayersData} style={{ width: "70px", height: "12px" }}>
          <SparklinesLine style={{ strokeWidth: 4, stroke: "white", fill: "none" }} />
        </Sparklines>
      );
    } else {
      return <Mmr data={oldMmr}></Mmr>;
    }
  };

  const LeftSlot = () => {
    if (side === "left") {
      return transition ? <p className="number">{rank ? `#${rank}` : ""}</p> : <Flag name={location?.toLowerCase()}></Flag>;
    } else {
      return <img src={raceIcon} alt={race} className={"race"} />;
    }
  };

  const RightSlot = () => {
    if (side === "right") {
      return transition ? <p className="number">{rank ? `#${rank}` : ""}</p> : <Flag name={location?.toLowerCase()}></Flag>;
    } else {
      return <img src={raceIcon} alt={race} className={"race"} />;
    }
  };

  const Name = () => {
    return aka !== null && transition ? aka : name;
  };

  return (
    <Grid divided="vertically" className={"playerCard"}>
      <Grid.Row columns={1} className={"playerTop"}>
        <Grid.Column width={16} className="playerName">
          <h2>
            <Name />
            {/* <a target="_blank" href={`/player/${battleTag.replace("#", "%23")}`} rel="noreferrer" className={aka && transition ? "playerMMrstat" : ""}>
              <Name></Name>
            </a> */}
          </h2>
        </Grid.Column>
      </Grid.Row>

      <Grid.Row columns={3} className={"playerBottom"}>
        <Grid.Column width={4} className={(side === "left") & allMmrsgathered ? "playerMMrstat number" : "number"}>
          <LeftSlot />
        </Grid.Column>
        <Grid.Column width={8} className={allMmrsgathered ? "playerMMrstat" : ""}>
          <PlayerMmrStatistic />
        </Grid.Column>
        <Grid.Column width={4} className={(side === "right") & allMmrsgathered ? "playerMMrstat number" : "number"}>
          <RightSlot />
        </Grid.Column>
      </Grid.Row>
    </Grid>
  );
};

export default Player;
```

## File: src/PlayerProfile.js
```javascript
import React, { useState, useEffect } from "react";
import { findPlayerInOngoingMatches } from "./utils.js";
import OnGoingGame from "./OngoingGame.js";
import human from "./icons/human.svg";
import orc from "./icons/orc.svg";
import elf from "./icons/elf.svg";
import undead from "./icons/undead.svg";
import random from "./icons/random.svg";

const PlayerProfile = () => {
  const [matchHistory, setMatchHistory] = useState([]);
  const [isLoaded, setIsLoaded] = useState(false);
  const [ongoingGame, setOngoingGame] = useState(null);
  const raceMapping = { 8: undead, 0: random, 4: elf, 2: orc, 1: human };
  const [race, setRace] = useState(null);

  useEffect(() => {
    // Immediately load data when the component mounts
    loadData();

    // Fetch ongoing games every 30 seconds
    const interval = setInterval(fetchOngoingGames, 30000);

    // Cleanup interval on component unmount
    return () => clearInterval(interval);
  }, []);

  const loadData = async () => {
    try {
      // Fetch ongoing games immediately
      // await fetchOngoingGames();

      // Other data loading logic here (e.g., player profile, match history, etc.)

      setIsLoaded(true);
    } catch (error) {
      console.error("Error loading data:", error);
    }
  };

  const fetchOngoingGames = async () => {
    try {
      // Fetch ongoing games API
      const ongoingResponse = await fetch("https://website-backend.w3champions.com/api/matches/ongoing");
      const ongoingResult = await ongoingResponse.json();

      // Extract tag from URL
      const pageUrl = new URL(window.location.href);
      const tag = pageUrl.pathname.split("/").slice(-1)[0].replace("%23", "#");

      // Find ongoing game for the player
      const ongoingGame = findPlayerInOngoingMatches(ongoingResult, tag);
      setOngoingGame(ongoingGame);
    } catch (error) {
      console.error("Error fetching ongoing games:", error);
    }
  };

  if (!isLoaded) return null;

  return (
    <div id="PlayerProfile" style={{ width: "50%" }}>
      {!ongoingGame ? (
        <></>
      ) : (
        <div id="ongoing">
          <OnGoingGame ongoingGameData={ongoingGame} />
        </div>
      )}
    </div>
  );
};

export default PlayerProfile;
```

## File: src/PlayerProfileBackup.js
```javascript
import React, { useState, useEffect } from "react";
import Navbar from "./Navbar";
import Match from "./Match";
import { Grid, Container, Divider, Flag, Image } from "semantic-ui-react";
import { findPlayerInOngoingMatches, findPlayerRaceInMatch, findPlayerMmrInMatch, fetchMMRTimeline, getPlayerProfilePicUrl, getPlayerCountry, standardDeviation, arithmeticMean } from "./utils.js";
import { Sparklines, SparklinesLine, SparklinesSpots } from "react-sparklines";
import OnGoingGame from "./OngoingGame.js";
import { gameMode, gateway, season } from "./params";
import { Link } from "react-router-dom";

import human from "./icons/human.svg";
import orc from "./icons/orc.svg";
import elf from "./icons/elf.svg";
import undead from "./icons/undead.svg";
import random from "./icons/random.svg";
import FinishedGame from "./FinishedGame.js";

const getMatchData = async (matchId) => {
  const url = `https://website-backend.w3champions.com/api/matches/${matchId}`;
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error("Failed to fetch match data");
  }
  return response.json();
};

const PlayerProfile = () => {
  const [matchHistory, setMatchHistory] = useState([]);
  const [isLoaded, setIsLoaded] = useState(false);
  const [ongoingGame, setOngoingGame] = useState(null);
  const [transition, setTransition] = useState(false);
  const [playerData, setPlayerData] = useState(null);
  const [ladderRanks, setLadderRanks] = useState([]);
  const [profilePic, setProfilePic] = useState(null);
  const [country, setCountry] = useState(null);
  const [mmrTimeLine, setMmrTimeline] = useState(null);
  const [mmr, setMmr] = useState(null);
  const raceMapping = { 8: undead, 0: random, 4: elf, 2: orc, 1: human };
  const [race, setRace] = useState(null);

  const loadData = async () => {
    const pageUrl = new URL(window.location.href);
    const player = pageUrl.pathname.split("/").slice(-1)[0];

    try {
      const playerResponse = await fetch(`https://website-backend.w3champions.com/api/players/${player}`);
      const playerResult = await playerResponse.json();
      console.log("playerResult", playerResult);
      setPlayerData(playerResult);

      const ongoingResponse = await fetch("https://website-backend.w3champions.com/api/matches/ongoing");
      const ongoingResult = await ongoingResponse.json();
      const ongoingGame = findPlayerInOngoingMatches(ongoingResult, playerResult.battleTag);
      setOngoingGame(ongoingGame);

      const searchParams = new URLSearchParams({
        offset: 0,
        gateway,
        pageSize: 200,
        season,
        gameMode: 4,
        playerId: playerResult.battleTag,
      });

      var url = new URL("https://website-backend.w3champions.com/api/ladder/0");
      var params = { gateway, season, gameMode };
      url.search = new URLSearchParams(params).toString();

      var response = await fetch(url);
      var result = await response.json();
      setLadderRanks(result.slice(0, 20));

      const profilePic = await getPlayerProfilePicUrl(playerResult.battleTag);
      setProfilePic(profilePic);

      const country = await getPlayerCountry(playerResult.battleTag);
      setCountry(country);

      const matchesResponse = await fetch(`https://website-backend.w3champions.com/api/matches/search?${searchParams}`);
      const matchesResult = await matchesResponse.json();
      let recentMatches = matchesResult.matches.slice(0, 5);
      const matchDataPromises = recentMatches.map((match) => getMatchData(match.id));
      const matchDataResults = await Promise.all(matchDataPromises);
      setMatchHistory(matchDataResults);

      const race = findPlayerRaceInMatch(recentMatches[0], playerResult.battleTag);
      setRace(race);

      const mmrCurrent = findPlayerMmrInMatch(recentMatches[0], playerResult.battleTag);
      setMmr(mmrCurrent);

      const mmrData = await fetchMMRTimeline(playerResult.battleTag, race); // Fetch MMR timeline data
      setMmrTimeline(mmrData);

      setIsLoaded(true);
    } catch (error) {
      console.error(error);
    }
  };

  if (!isLoaded || !playerData || !mmrTimeLine) return null;
  return (
    <div>
      {!ongoingGame ? (
        <></>
      ) : (
        <div id="ongoing">
          {/* <h1>Ongoing Game</h1> */}
          <OnGoingGame ongoingGameData={ongoingGame} />
        </div>
      )}
      {/* {!matchHistory ? (
        <></>
      ) : (
        <div id="history">
          <h1>Game History</h1>
          {matchHistory.map((d) => (
            <FinishedGame data={d} />
          ))}
        </div>
      )} */}
    </div>
  );
};

export default PlayerProfile;

{
  /* <Navbar />
<div className={`team-0 max-width-cell`} style={{ position: "relative" }}>
  <div style={{ position: "relative" }}>
    <img src={profilePic} alt="Player Profile Pic" className="profile-pic " />
    <Flag name={country.toLowerCase()} style={{ position: "absolute", top: 0, right: 0 }} className={`flag`}></Flag>
  </div>
  <div>
    <Link to={`/player/${playerData.battleTag.replace("#", "%23")}`}>
      <h2>{playerData.name}</h2>
    </Link>
  </div>
  <div>
    <img src={raceMapping[race]} alt={race} className={"race"} style={{ height: "40px" }} />
  </div>
  <div>
    <p className="key">
      <span className="number value">{mmr}</span> <span className="key">MMR</span>
    </p>
  </div>
  <div style={{ width: "200px", height: "20px", overflow: "hidden", display: "inline-block", marginTop: "10px" }}>
    {mmrTimeLine && mmrTimeLine.length > 0 ? (
      <Sparklines data={mmrTimeLine} style={{ width: "130px", height: "14px" }}>
        <SparklinesLine style={{ strokeWidth: 4, stroke: "white", fill: "none" }} />
      </Sparklines>
    ) : (
      <div>No data available</div>
    )}
  </div>
</div> */
}
```

## File: src/PlayerStream.js
```javascript
import React, { useState, useEffect } from "react";
import { findPlayerInOngoingMatches } from "./utils.js";
import OnGoingGame from "./OngoingGame.js";
import human from "./icons/human.svg";
import orc from "./icons/orc.svg";
import elf from "./icons/elf.svg";
import undead from "./icons/undead.svg";
import random from "./icons/random.svg";

const PlayerProfile = () => {
  const [matchHistory, setMatchHistory] = useState([]);
  const [isLoaded, setIsLoaded] = useState(false);
  const [ongoingGame, setOngoingGame] = useState(null);
  const raceMapping = { 8: undead, 0: random, 4: elf, 2: orc, 1: human };
  const [race, setRace] = useState(null);

  useEffect(() => {
    // Immediately load data when the component mounts
    loadData();

    // Fetch ongoing games every 30 seconds
    const interval = setInterval(fetchOngoingGames, 30000);

    // Cleanup interval on component unmount
    return () => clearInterval(interval);
  }, []);

  const loadData = async () => {
    try {
      // Fetch ongoing games immediately
      await fetchOngoingGames();

      // Other data loading logic here (e.g., player profile, match history, etc.)

      setIsLoaded(true);
    } catch (error) {
      console.error("Error loading data:", error);
    }
  };

  const fetchOngoingGames = async () => {
    try {
      // Fetch ongoing games API
      const ongoingResponse = await fetch("https://website-backend.w3champions.com/api/matches/ongoing");
      const ongoingResult = await ongoingResponse.json();

      // Extract tag from URL
      const pageUrl = new URL(window.location.href);
      const tag = pageUrl.pathname.split("/").slice(-1)[0].replace("%23", "#");

      // Find ongoing game for the player
      const ongoingGame = findPlayerInOngoingMatches(ongoingResult, tag);
      setOngoingGame(ongoingGame);
    } catch (error) {
      console.error("Error fetching ongoing games:", error);
    }
  };

  if (!isLoaded) return null;

  return (
    <div id="PlayerProfile" style={{ width: "50%" }}>
      {!ongoingGame ? (
        <></>
      ) : (
        <div id="ongoing">
          <OnGoingGame ongoingGameData={ongoingGame} compact={true} />
        </div>
      )}
    </div>
  );
};

export default PlayerProfile;
```

## File: src/Queue.js
```javascript
import React, { Component } from "react";
import {
  Container,
  Grid,
  Statistic,
  Divider,
  Dimmer,
  Loader,
} from "semantic-ui-react";

import Navbar from "./Navbar.js";
import Player from "./Player.js";

// const socket = new WebSocket(
//   "ws://157.90.1.251:25058/?%7B%22battleTag%22:%22WEAREFOALS%25231522%22,%22gateway%22:20,%22gatewayPing%22:218,%22toonName%22:%22WEAREFOALS%25231522%22,%22token%22:%22%22,%22country%22:%22GB%22,%22ipAddress%22:%2237.156.72.6%22%7D"
// );

const timeCuttoffForRecent = 20;
class Queue extends Component {
  state = {
    ONLINE_PLAYER_COUNT: [],
    QUEUED_PLAYER_COUNT: [],
    queue: [],
    matches: [],
    recentMatches: [],
    playerPoolRecent: [],
    playerPoolPlaying: [],
    playerPool: [],
    isLoaded: false,
  };

  componentDidMount() {
    this.loadData();
    let intervalId = setInterval(this.loadData, 30000);

    this.setState({ intervalId });
  }

  componentWillUnmount() {
    clearInterval(this.state.intervalId);
  }

  loadData = async () => {
    fetch(
      "https://website-backend.w3champions.com/api/matches?offset=0&gateway=20&pageSize=50&gameMode=4&map=Overall"
    )
      .then((response) => response.json())
      .then(
        (result) => {
          result.matches.forEach(
            (d) =>
              (d["timePassedSinceMatch"] =
                (Date.now() - new Date(d.endTime)) / (60 * 1000))
          );
          // console.log("MATCHES", result.matches);
          const recentMatches = result.matches.filter(
            (d) => d["timePassedSinceMatch"] <= timeCuttoffForRecent
          );

          console.log("recentMatches", recentMatches);

          let playerPoolRecent = [];
          recentMatches.forEach((d) =>
            d.teams.forEach((team) =>
              team.players.forEach((player) => {
                player["ingame"] = false;
                player["timePassedSinceMatch"] = d.timePassedSinceMatch;
                //   player["timePassedSinceMatch"] = ;
                playerPoolRecent.push(player);
              })
            )
          );

          // playerPoolRecent = [...this.state.playerPool, ...playerPoolRecent];
          playerPoolRecent = [
            ...new Map(
              playerPoolRecent.map((item) => [item["battleTag"], item])
            ).values(),
          ];
          let playersPlaying = this.state.playerPoolPlaying.map(
            (d) => d["battleTag"]
          );
          playerPoolRecent = playerPoolRecent.filter(
            (d) => !playersPlaying.includes(d["battleTag"])
          );
          // playerPoolRecent = playerPoolRecent.filter((x) => this.state.playerPoolPlaying.map((d) => d["battleTag"].includes(x.id)));
          playerPoolRecent.sort((a, b) => b.currentMmr - a.currentMmr);
          this.setState({
            recentMatches,
            playerPoolRecent: playerPoolRecent,
            isLoaded: true,
          });
        },
        (error) => {
          this.setState({
            isLoaded: true,
            error,
          });
        }
      );

    fetch("https://website-backend.w3champions.com/api/matches/ongoing")
      .then((response) => response.json())
      .then(
        (result) => {
          const relevantMatches = result.matches
            ? result.matches.filter((d) => d.gateWay === 20 && d.gameMode === 4)
            : [];
          let playerPoolPlaying = [];
          relevantMatches.forEach((d) =>
            d.teams.forEach((team) =>
              team.players.forEach((player) => {
                player["ingame"] = true;
                playerPoolPlaying.push(player);
              })
            )
          );
          playerPoolPlaying = [...this.state.playerPool, ...playerPoolPlaying];
          playerPoolPlaying = [
            ...new Map(
              playerPoolPlaying.map((item) => [item["battleTag"], item])
            ).values(),
          ];
          playerPoolPlaying.sort((a, b) => b.oldMmr - a.oldMmr);
          console.log("relevantMatches", relevantMatches);
          this.setState({
            matches: relevantMatches, // ? result.matches.filter((d) => d.gameMode === 2) : [],
            // [type]: data,
            playerPoolPlaying: playerPoolPlaying,
          });
        },
        (error) => {
          this.setState({
            isLoaded: true,
            error,
          });
        }
      );
  };

  //   componentWillMount() {

  //       //   this.setState({
  //       //     matches: relevantMatches, // ? result.matches.filter((d) => d.gameMode === 2) : [],
  //       //     [type]: data,
  //       //     playerPoolPlaying: playerPoolPlaying,
  //       //   });

  //   }

  render() {
    // socket.onmessage = (event) => {
    //   const msg = JSON.parse(event.data);
    //   const type = msg.type;
    //   const data = msg.data;
    //   console.log(msg, type, data);
    // };

    const queueDict = this.state.QUEUED_PLAYER_COUNT
      ? this.state.QUEUED_PLAYER_COUNT.filter(
          (d) => d.gateway === 20 && d.gameMode === 4
        )[0]
      : {};
    const numQueued = queueDict ? queueDict.count : 0;
    const playerPoolPlaying = this.state.playerPoolPlaying;
    const playerPoolRecent = this.state.playerPoolRecent;

    if (this.state.isLoaded === true) {
      return (
        <Container>
          <Navbar />

          <Grid columns={3}>
            <Grid.Row columns={3}>
              <Grid.Column width={6}>
                <Statistic inverted>
                  <Statistic.Value>
                    {this.state.playerPoolPlaying.length}
                  </Statistic.Value>
                  <Statistic.Label>Currently Playing</Statistic.Label>
                </Statistic>
                {Object.keys(playerPoolPlaying).map((key) => (
                  <Player
                    key={playerPoolPlaying[key].name}
                    data={playerPoolPlaying[key]}
                    noteApiAttempted={function () {
                      return;
                    }}
                  ></Player>
                ))}
              </Grid.Column>
              <Grid.Column width={2} />
              <Grid.Column width={6}>
                <Statistic inverted>
                  <Statistic.Value>
                    {this.state.playerPoolRecent.length}
                  </Statistic.Value>
                  <Statistic.Label>Recently Finished</Statistic.Label>
                </Statistic>
                {/* <TeamHeader teamNum={1000} teamMmr={2000} won={true}></TeamHeader> */}
                {Object.keys(playerPoolRecent).map((key) => (
                  <Player
                    key={playerPoolRecent[key].name}
                    data={playerPoolRecent[key]}
                  ></Player>
                ))}
              </Grid.Column>
            </Grid.Row>
          </Grid>
          <Divider />
        </Container>
      );
    } else {
      return (
        <Container>
          <Navbar />

          <Grid columns={3}>
            <Grid.Row columns={3}>
              {/* <Segment> */}
              <Dimmer active>
                <Loader />
              </Dimmer>
            </Grid.Row>
          </Grid>
        </Container>
      );
    }
  }
}

export default Queue;
```

## File: src/RankRow.js
```javascript
import React, { Component } from "react";

import { Container, Flag, Header, Table, Rating } from "semantic-ui-react";
import { Sparklines, SparklinesLine, SparklinesSpots } from "react-sparklines";

import { gameMode, gateway, season } from "./params";

import human from "./icons/human.svg";
import orc from "./icons/orc.svg";
import elf from "./icons/elf.svg";
import undead from "./icons/undead.svg";
import random from "./icons/random.svg";

class RankRow extends Component {
  state = {
    race: 0,
    sparklinePlayersData: [],
  };

  componentDidMount() {
    this.loadData();
    console.log(this.props);
  }

  loadData = async () => {
    const player = this.props.rank.playersInfo[0].battleTag.replace("#", "%23");
    const race = this.props.rank.playersInfo[0].calculatedRace;
    this.setState({ race });

    try {
      let sparklinePlayersData = [];
      var url = new URL(`https://website-backend.w3champions.com/api/players/${player}/mmr-rp-timeline`);
      var params = {
        gateway,
        season: season - 1,
        race,
        gameMode: 4,
      };
      url.search = new URLSearchParams(params).toString();
      var response = await fetch(url);
      var result = await response.json();
      if ("mmrRpAtDates" in result) {
        const prevSeasonMMrs = result.mmrRpAtDates
          .map((d) => d.mmr)
          .slice(1)
          .slice(-20);
        sparklinePlayersData = [...sparklinePlayersData, ...prevSeasonMMrs];
      }

      var url = new URL(`https://website-backend.w3champions.com/api/players/${player}/mmr-rp-timeline`);
      var params = { gateway, season, race, gameMode: 4 }; //hardcodig race at the moment
      url.search = new URLSearchParams(params).toString();
      var response = await fetch(url);
      var result = await response.json();
      if ("mmrRpAtDates" in result) {
        const thisSeasonMMrs = result.mmrRpAtDates.map((d) => d.mmr);
        sparklinePlayersData = [...sparklinePlayersData, ...thisSeasonMMrs];
        this.setState({ sparklinePlayersData, attemptedAPI: true });
      }
    } catch (e) {
      console.log("cannot fetch data for a player", player, e);
      this.setState({ attemptedAPI: true });
    }
  };

  render() {
    const { name, mmr, wins, losses, winrate } = { ...this.props.rank.player };
    const battleTag = this.props.rank.playersInfo[0].battleTag;
    const raceMapping = {
      8: undead,
      0: random,
      4: elf,
      2: orc,
      1: human,
    };
    const raceIcon = raceMapping[this.state.race];

    return (
      <Table.Row>
        <Table.Cell>
          <Header textAlign="center" inverted>
            {this.props.rank.rankNumber}
          </Header>
        </Table.Cell>
        <Table.Cell>{this.props.rank.rankingPoints.toFixed(2)}</Table.Cell>
        <Table.Cell textAlign="center">
          <img src={raceIcon} alt={this.state.race} className={"race"} textAlign="center" style={{ width: "30px" }} />
        </Table.Cell>
        <Table.Cell singleLine>
          <a target="_blank" href={`/player/${battleTag.replace("#", "%23")}`} rel="noreferrer">
            {name}
          </a>
        </Table.Cell>

        <Table.Cell textAlign="right">{mmr}</Table.Cell>
        <Table.Cell>{wins}</Table.Cell>
        <Table.Cell>{losses}</Table.Cell>
        <Table.Cell>{Math.round(winrate * 10000) / 100}%</Table.Cell>

        <Table.Cell>
          <Sparklines data={this.state.sparklinePlayersData} style={{ width: "70px", height: "12px" }}>
            <SparklinesLine style={{ strokeWidth: 4, stroke: "white", fill: "none" }} />
          </Sparklines>
        </Table.Cell>
      </Table.Row>
    );
  }
}

export default RankRow;
```

## File: src/RecentlyFinished.js
```javascript
import React, { useState, useEffect } from "react";
import { Container, Dimmer, Loader } from "semantic-ui-react";
import Game from "./Game.js";
import Navbar from "./Navbar.js";
import FinishedGame from "./FinishedGame.js";
import OnGoingGame from "./OngoingGame.js";
import { calculateTeamMMR, getPlayerProfilePicUrl, fetchMMRTimeline, getPlayerCountry } from "./utils.js";
import { gameMode, gateway, season } from "./params";

function isLessThan30MinutesAgo(endTimeString) {
  // Convert the endTime string to a Date object
  const endTime = new Date(endTimeString);
  // Get the current time
  const currentTime = new Date();

  // Calculate the difference in milliseconds between current time and endTime
  const differenceInMilliseconds = currentTime - endTime;

  // Convert the difference to minutes
  const differenceInMinutes = differenceInMilliseconds / (1000 * 60);

  // Return true if the difference is less than 30 minutes
  return differenceInMinutes < 30;
}

const RecentlyFinished = () => {
  const [finishedGameData, setFinishedGameData] = useState(null);
  const [matchesData, setMatchesData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    fetchFinishedMatchesData();
  }, []);

  const getMatchData = async (matchId) => {
    const url = `https://website-backend.w3champions.com/api/matches/${matchId}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error("Failed to fetch match data");
    }
    return response.json();
  };

  const fetchFinishedMatchesData = async () => {
    try {
      const response = await fetch(`https://website-backend.w3champions.com/api/matches?offset=0&gateway=${gateway}&pageSize=50&gameMode=${gameMode}&map=Overall`);
      if (!response.ok) {
        throw new Error("Failed to fetch ongoing matches data");
      }
      const data = await response.json();

      // Filter the data
      const filteredData = data.matches.filter((match) => isLessThan30MinutesAgo(match.endTime));
      console.log("filteredData", filteredData);

      const sortedMatches = filteredData.slice().sort((a, b) => {
        const teamAMMR = calculateTeamMMR(a.teams);
        const teamBMMR = calculateTeamMMR(b.teams);
        return teamBMMR - teamAMMR;
      });

      setFinishedGameData(sortedMatches);

      // Fetch match data for each gameId in filteredData
      const matchDataPromises = sortedMatches.map((match) => getMatchData(match.id));
      const matchDataResults = await Promise.all(matchDataPromises);

      console.log("matchDataResults", matchDataResults);
      setMatchesData(matchDataResults);

      setIsLoading(false);
    } catch (error) {
      console.error("Error fetching match data:", error.message);
      setIsLoading(false);
    }
  };

  return (
    <>
      {isLoading ? (
        <Dimmer active>
          <Loader size="large">Loading match data...</Loader>
        </Dimmer>
      ) : matchesData ? (
        <div>
          <Navbar />
          <div className="games">
            {matchesData.map((d) => (
              <FinishedGame data={d} />
            ))}
          </div>
        </div>
      ) : (
        <div>
          Error: Failed to load match data
          <p>{JSON.stringify(finishedGameData)}</p>
        </div>
      )}
    </>
  );
};

export default RecentlyFinished;
```

## File: src/reportWebVitals.js
```javascript
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
```

## File: src/Router.js
```javascript
import React from "react";
import { BrowserRouter, Route, Switch } from "react-router-dom";
import App from "./App";
import Queue from "./Queue";
import OnGoingGames from "./OnGoingGames";
import Ladder from "./Ladder";
import PlayerProfile from "./PlayerProfile";
import PlayerStream from "./PlayerStream";
import FinishedGamePage from "./FinishedGamePage";
import RecentlyFinished from "./RecentlyFinished";
import MyStreamPage from "./MyStreamPage";

const Router = () => (
  <BrowserRouter>
    <Switch>
      <Route exact path="/" component={OnGoingGames} />
      <Route exact path="/queue" component={Queue} />
      <Route path="/ongoing" component={OnGoingGames} />
      <Route path="/finished" component={RecentlyFinished} />
      <Route path="/ladder" component={Ladder} />
      <Route path="/player" component={PlayerProfile} />
      <Route path="/stream" component={PlayerStream} />
      <Route path="/match" component={FinishedGamePage} />
      <Route path="/mystream" component={MyStreamPage} />
    </Switch>
  </BrowserRouter>
);

export default Router;
```

## File: src/SeamlessBackground.js
```javascript
import React, { useRef, useEffect } from "react";
import styled from "styled-components";

const VideoContainer = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  z-index: -1000;
`;

const VideoBackground = styled.video`
  position: absolute;
  top: 50%;
  left: 50%;
  width: 100vw;
  height: 100vh;
  object-fit: cover;
  transform: translate(-55%, -50%) scale(1); /* Slight scale to cover potential gaps */
`;

const ContentWrapper = styled.div`
  position: relative;
  z-index: 1;
`;

const ResponsiveFullscreenVideoBackground = ({ children }) => {
  const videoRef = useRef(null);

  useEffect(() => {
    const handleResize = () => {
      if (videoRef.current) {
        const { width, height } = videoRef.current.getBoundingClientRect();
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const scale = Math.max(windowWidth / width, windowHeight / height);
        videoRef.current.style.transform = `translate(-50%, -50%) scale(${scale})`;
      }
    };

    window.addEventListener("resize", handleResize);
    handleResize(); // Initial call

    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return (
    <>
      <VideoContainer>
        <VideoBackground ref={videoRef} autoPlay loop muted playsInline>
          <source src="/backgrounds/peace-in-ashenvale-world-of-warcraft-moewalls-com.mp4" type="video/mp4" />
          Your browser does not support the video tag.
        </VideoBackground>
      </VideoContainer>
      <ContentWrapper>{children}</ContentWrapper>
    </>
  );
};

export default ResponsiveFullscreenVideoBackground;
```

## File: src/setupTests.js
```javascript
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';
```

## File: src/Team.js
```javascript
import React, { Component } from "react";
import Player from "./Player.js";
import TeamHeader from "./TeamHeader.js";

class Team extends Component {
  render() {
    let {
      team,
      teamNum,
      teamAverage,
      teamDeviation,
      sparklinePlayersData,
      ladderRanks,
    } = this.props;
    const won = team.won;
    sparklinePlayersData = sparklinePlayersData || {};

    return (
      <div className={"teamDiv"}>
        <TeamHeader
          teamNum={teamNum}
          teamMmr={teamAverage}
          teamDeviation={teamDeviation}
          won={won}
          transition={this.props.transition}
        ></TeamHeader>

        {Object.keys(team.players).map((key) => (
          <Player
            key={team.players[key].name}
            rank={ladderRanks.filter(
              (d) => d.player1Id === team.players[key].battleTag
            )}
            data={team.players[key]}
            side={this.props.side}
            transition={this.props.transition}
            sparklinePlayersData={
              team.players[key].battleTag in sparklinePlayersData
                ? sparklinePlayersData[team.players[key].battleTag]
                : []
            }
            noteApiAttempted={this.props.noteApiAttempted}
            allMmrsgathered={this.props.allMmrsgathered}
          ></Player>
        ))}
      </div>
    );
  }
}

export default Team;
```

## File: src/TeamHeader.js
```javascript
import React, { Component } from "react";
import { Grid } from "semantic-ui-react";
import { TransitionGroup, CSSTransition } from "react-transition-group";

import Mmr from "./Mmr.js";

class TeamHeader extends Component {
  render() {
    let { teamNum, teamMmr, teamDeviation, won } = this.props;
    // console.log(this.props)
    if (teamMmr !== undefined) {
      teamMmr = teamMmr.toLocaleString();
    }
    let statistic = this.props.transition ? `  = ${teamDeviation}` : `x = ${teamMmr}`;
    return (
      <Grid divided="vertically" className={`team-header team-${teamNum}`}>
        {/* <Grid.Row columns={2} className={"playerBottom"}>
          <Grid.Column width={4}>
            <span>{won ? <img src={crown} alt={"asd"} className={"crown"} /> : ""}</span>
          </Grid.Column>
          <Grid.Column className="playerName">
            Team <span className={"teamNum"}>{teamNum}</span>
          </Grid.Column>
        </Grid.Row> */}
        <Grid.Row columns={1} className={"playerTop"}>
          <Grid.Column>
            {/* className={"playerMMrstat"}> */}
            <Mmr data={teamMmr}></Mmr>
          </Grid.Column>
        </Grid.Row>
      </Grid>
    );
  }
}

export default TeamHeader;
```

## File: src/Time.js
```javascript
import React, { Component } from "react";

class Time extends Component {
  render() {
    // const { team, teamNum } = this.props;

    return <div></div>;
  }
}

export default Time;
```

## File: src/utils.js
```javascript
import { DateTime } from "luxon";
import { gameMode, gateway, season } from "./params";

export const standardDeviation = (array) => {
  const n = array.length;
  const mean = array.reduce((a, b) => a + b) / n;
  const dev = Math.sqrt(array.map((x) => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n);
  return Math.round(dev);
};

export const arithmeticMean = (x) => {
  const product = x.reduce((p, c) => p * c, 1);
  const exponent = 1 / x.length;
  return Math.round(Math.pow(product, exponent));
};

export const getUniqueListBy = (arr, key) => [...new Map(arr.map((item) => [item[key], item])).values()];

export const akaLookup = (aka) => {
  const mapping = {
    : "hainiu",
    : "bonggo",
    : "tiny tauren",
  };

  const name = mapping[aka] || null;
  return name;
};

export const raceLookup = (aka) => {
  const mapping = {
    "Teo#23801": "hainiu",
  };

  const name = mapping[aka] || null;
  return name;
};

export const calcPlayerMmrAndChange = (battleTag, match) => {
  for (const team of match.teams) {
    for (const player of team.players) {
      if (player.battleTag === battleTag) {
        const mmr = player.currentMmr;
        const oldMmr = player.oldMmr;
        let mmrChange = player.mmrGain.toString(); // Convert mmrChange to a string
        if (player.mmrGain > 0) {
          mmrChange = `+${mmrChange}`;
        }
        return { oldMmr, mmrChange };
      }
    }
  }
  return null;
};

export const calculatePercentiles = (arr) => {
  // console.log(arr);
  // Sort the array in ascending order
  const sortedArr = arr.slice().sort((a, b) => a - b);
  const n = sortedArr.length;

  // Calculate percentile for each element
  const percentiles = arr.map((num) => {
    // Find the index of the number in the sorted array
    const index = sortedArr.indexOf(num);

    // Calculate percentile using index and array length
    const percentile = (index / (n - 1)) * 100;
    return percentile;
  });
  return percentiles;
};

export const preprocessPlayerScores = (match, playerScores) => {
  // Define the key display name mapping
  const keyDisplayNameMapping = {
    heroesKilled: "Heroes Killed",
    expGained: "Experience Gained",
    goldCollected: "Gold Mined",
    unitsProduced: "Units Produced",
    unitsKilled: "Units Killed",
    largestArmy: "Largest Army",
    lumberCollected: "Lumber Harvested",
    goldUpkeepLost: "Gold Lost to Upkeep",
  };

  const dataTypes = ["heroScore", "resourceScore", "unitScore"];

  let stats = {};
  for (const dataType of dataTypes) {
    for (const [statName, value] of Object.entries(playerScores[0][dataType])) {
      const values = playerScores.map((d) => d[dataType][statName]);
      let percentiles = calculatePercentiles(values);

      // If the statName is "goldUpkeepLost", reverse the percentiles
      if (statName === "goldUpkeepLost") {
        percentiles = percentiles.map((d) => 100 - d);
      }
      const displayName = keyDisplayNameMapping[statName] || statName;
      stats[displayName] = { percentiles, values };
    }
  }

  let mvpData = {};
  const mvpKeys = ["Heroes Killed", "Experience Gained", "Gold Mined", "Units Killed", "Largest Army"];
  for (let i = 0; i < 8; i++) {
    const playerName = playerScores[i].battleTag.split("#")[0];
    let summed = 0;
    for (const dataType of mvpKeys) {
      const percentiles = stats[dataType].percentiles;
      summed += percentiles[i];
    }
    mvpData[playerName] = summed;
  }

  const [mvp, maxValue] = Object.entries(mvpData).reduce((acc, [key, value]) => (value > acc[1] ? [key, value] : acc), ["", -Infinity]);

  const playerData = match.teams.flatMap((team, teamIndex) => {
    return team.players.map((playerData) => {
      const playerScore = playerScores.find((score) => score.battleTag === playerData.battleTag);
      const { oldMmr, mmrChange } = calcPlayerMmrAndChange(playerData.battleTag, match);
      const isMvp = playerData.battleTag.split("#")[0] === mvp ? true : false;
      return {
        ...playerScore,
        ...playerData,
        oldMmr,
        mmrChange,
        isMvp,
      };
    });
  });

  const metaData = {
    startTime: match.startTime, //.slice(0, 16).replace("T", " "),
    gameLength: `${Math.floor(match.durationInSeconds / 60)}:${(match.durationInSeconds % 60).toString().padStart(2, "0")}`,
    server: match.serverInfo.name?.toUpperCase(),
    location: match.serverInfo.location?.toUpperCase(),
    mapName: match.mapName?.toUpperCase(),
  };

  return { playerData, metaData, stats };
};

export const processOngoingGameData = (match) => {
  // Process each ongoing game
  const playerData = match.teams.flatMap((team, teamIndex) => {
    return team.players.map((playerData) => {
      return {
        ...playerData,
      };
    });
  });

  const metaData = {
    startTime: match.startTime, //.slice(0, 16).replace("T", " "),
    gameLength: `${Math.floor(match.durationInSeconds / 60)}:${(match.durationInSeconds % 60).toString().padStart(2, "0")}`,
    server: match.serverInfo.name?.toUpperCase(),
    location: match.serverInfo.location?.toUpperCase(),
    mapName: match.mapName?.toUpperCase(),
  };

  return { playerData, metaData };
};

export const getPlayerProfilePicUrl = async (battleTag) => {
  try {
    const response = await fetch(`https://website-backend.w3champions.com/api/personal-settings/${encodeURIComponent(battleTag)}`);
    const profileData = await response.json();
    const { profilePicture } = profileData;
    if (!profilePicture || !profilePicture.pictureId) {
      return null;
    }
    const { pictureId, race } = profilePicture;
    const raceMapping = { 64: "starter", 16: "total", 8: "undead", 0: "random", 4: "nightelf", 2: "orc", 1: "human" };
    const { specialPictures } = profileData;
    if (specialPictures.map((d) => d.pictureId).includes(pictureId)) {
      return `https://w3champions.wc3.tools/prod/integration/icons/specialAvatars/SPECIAL_${pictureId}.jpg`;
    } else {
      return `https://w3champions.wc3.tools/prod/integration/icons/raceAvatars/classic/${raceMapping[race].toUpperCase()}_${pictureId}.jpg`;
    }
  } catch (error) {
    console.error("Error fetching player profile picture:", error);
    return null;
  }
};

export const findPlayerRaceInMatch = (matchData, playerBattleTag) => {
  for (const team of matchData.teams) {
    for (const player of team.players) {
      if (player.battleTag === playerBattleTag) {
        return player.race;
      }
    }
  }
  return null; // Player not found in the match
};

export const findPlayerMmrInMatch = (matchData, playerBattleTag) => {
  for (const team of matchData.teams) {
    for (const player of team.players) {
      if (player.battleTag === playerBattleTag) {
        return player.currentMmr;
      }
    }
  }
  return null; // Player not found in the match
};

export const findPlayerInOngoingMatches = (allMatchData, playerBattleTag) => {
  for (const matchData of allMatchData.matches) {
    for (const team of matchData.teams) {
      for (const player of team.players) {
        if (player.battleTag === playerBattleTag) {
          return matchData;
        }
      }
    }
  }
  return null; // Player not found in the match
};

export const fetchMMRTimeline = async (battleTag, race) => {
  const url = new URL(`https://website-backend.w3champions.com/api/players/${battleTag.replace("#", "%23")}/mmr-rp-timeline`);
  const params = { gateway, season, race, gameMode: 4 };
  url.search = new URLSearchParams(params).toString();
  try {
    const response = await fetch(url);
    const result = await response.json();
    const mmrTimeline = result.mmrRpAtDates.map((d) => d.mmr);
    return mmrTimeline;
  } catch (error) {
    console.error("Error fetching MMR timeline:", error);
    return [];
  }
};

export const getPlayerCountry = async (battleTag) => {
  try {
    const response = await fetch(`https://website-backend.w3champions.com/api/personal-settings/${encodeURIComponent(battleTag)}`);
    const profileData = await response.json();
    return profileData.location || null;
  } catch (error) {
    console.error("Error fetching player country:", error);
    return null;
  }
};

export const calculateTeamMMR = (teams) => {
  // Calculate team MMR as the sum of all players' currentMmr in a team
  return teams.reduce((total, team) => {
    return total + team.players.reduce((teamTotal, player) => teamTotal + player.oldMmr, 0);
  }, 0);
};

export function calculateElapsedTime(utcDate) {
  const localDate = new Date(utcDate);
  const now = new Date();
  const diffMs = now - localDate;
  const diffMins = Math.round(((diffMs % 86400000) % 3600000) / 60000); // minutes
  return diffMins;
}

export function convertToLocalTime(utcDate) {
  const localDate = new Date(utcDate);
  return localDate.toLocaleString();
}
```

## File: .gitignore
```
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# TypeScript v1 declaration files
typings/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test

# parcel-bundler cache (https://parceljs.org/)
.cache

# Next.js build output
.next

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and *not* Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Local Netlify folder
.netlify
.vercel

.DS_Store
package-lock.json
yarn.lock
build/static/.DS_Store
src/.DS_Store
public/.DS_Store
src/.DS_Store
src/.DS_Store
src/icons/.DS_Store
public/.DS_Store
src/.DS_Store
```

## File: README.md
```markdown
# 4v4.gg

## Ideas

Make the match background a gradient depending on the races?

## Next steps

Collect all 4v4 matches in game history
Put test data candlesticks up
Think about which is better:
do it per game,
do it per day and get all available

Candlestick chart
https://codepen.io/kryo2k/pen/pJxqBN

http://bl.ocks.org/andredumas/27c4a333b0e0813e093d

https://observablehq.com/@seanlaff/candlestick

## Destructing W3C data

- gateways
  - 20: europe
- gameMode
  - 4: 4v4
- Races:
  - 8: undead

## Resources

https://github.com/w3champions/website/tree/master/src/assets/TournamenBadges
https://observablehq.com/@irenedelatorre/wonderful-wednesday-april-2021-copd-app-data
https://observablehq.com/@d3/candlestick-chart

## Styles

- https://densitydesign.github.io/teaching-dd14/es02/group04/question01
- https://monkeytype.com/

## TODO

- player card

  - ~~country flags~~
  - ~~race~~
  - combine flags? https://fakeflag.net/

- stream version

  - ~~compact~~
  - transparent background?

- time series

  - record last 15 mins, plot graph of games and players?

- match

  - how long it has been going

- Range plot for MMR

  - stutter close dots
  - better axis annotation
  - additional plot with all game mmr on it? Box plot?
  - sparkline plot? (form for last 10 games?)

- Render a historical Game id
- Select game by player
- Select game by id

Where to include game id and date?

Search bar for player and game id,
Summary of different lobby types
Breakdown of player/team cards and assignment of lobbies (standard deviation)

## Improvements

utilise public folder in "player.js" like i did in "playerprofile.js" - seems the proper way to do it
google translate account names?

Check if there's a way around ws being insecure for num in queue
Visualization for how many in game, how many searching, how many recently finished
~~Add headers in navbar for home, player, queue~~
~~Add a match page~~
add line chart for RP/MMR gain
add ping information

add standard deviation to team header, transition

## Ideas

Add a feature to vote on who you think will win
Add a feature to vote on post game MVP

# TODO new

order races so that they are easier to compare
draw a line between AT partners
do a ongoing match view, that's also suitable for stream
upscale race icons
add gold circle to mmr trend

export NODE_OPTIONS=--openssl-legacy-provider
```
